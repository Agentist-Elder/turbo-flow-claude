#![allow(warnings)]
// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use crate::common_generated::*;
use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod mothership {
  pub use crate::common_generated::mothership::common;

  use crate::common_generated::*;
  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod gateway {

  use crate::common_generated::*;
  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_HTTP_METHOD: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_HTTP_METHOD: u8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_HTTP_METHOD: [HttpMethod; 5] = [
  HttpMethod::GET,
  HttpMethod::POST,
  HttpMethod::PUT,
  HttpMethod::PATCH,
  HttpMethod::DELETE,
];

/// HTTP method — enum keeps it to 1 byte, avoids string comparison in hot path.
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct HttpMethod(pub u8);
#[allow(non_upper_case_globals)]
impl HttpMethod {
  pub const GET: Self = Self(0);
  pub const POST: Self = Self(1);
  pub const PUT: Self = Self(2);
  pub const PATCH: Self = Self(3);
  pub const DELETE: Self = Self(4);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::GET,
    Self::POST,
    Self::PUT,
    Self::PATCH,
    Self::DELETE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::GET => Some("GET"),
      Self::POST => Some("POST"),
      Self::PUT => Some("PUT"),
      Self::PATCH => Some("PATCH"),
      Self::DELETE => Some("DELETE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for HttpMethod {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for HttpMethod {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for HttpMethod {
    type Output = HttpMethod;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for HttpMethod {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for HttpMethod {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for HttpMethod {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SERVICE_TARGET: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SERVICE_TARGET: u8 = 6;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SERVICE_TARGET: [ServiceTarget; 7] = [
  ServiceTarget::ShieldService,
  ServiceTarget::PolicyEngine,
  ServiceTarget::ThreatIntel,
  ServiceTarget::AuditLog,
  ServiceTarget::NeuralTrader,
  ServiceTarget::SentinelRelay,
  ServiceTarget::WasmGateRelay,
];

/// Upstream service target — compact routing key replacing URL strings.
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ServiceTarget(pub u8);
#[allow(non_upper_case_globals)]
impl ServiceTarget {
  pub const ShieldService: Self = Self(0);
  pub const PolicyEngine: Self = Self(1);
  pub const ThreatIntel: Self = Self(2);
  pub const AuditLog: Self = Self(3);
  pub const NeuralTrader: Self = Self(4);
  pub const SentinelRelay: Self = Self(5);
  pub const WasmGateRelay: Self = Self(6);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 6;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ShieldService,
    Self::PolicyEngine,
    Self::ThreatIntel,
    Self::AuditLog,
    Self::NeuralTrader,
    Self::SentinelRelay,
    Self::WasmGateRelay,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::ShieldService => Some("ShieldService"),
      Self::PolicyEngine => Some("PolicyEngine"),
      Self::ThreatIntel => Some("ThreatIntel"),
      Self::AuditLog => Some("AuditLog"),
      Self::NeuralTrader => Some("NeuralTrader"),
      Self::SentinelRelay => Some("SentinelRelay"),
      Self::WasmGateRelay => Some("WasmGateRelay"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ServiceTarget {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ServiceTarget {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ServiceTarget {
    type Output = ServiceTarget;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ServiceTarget {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ServiceTarget {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ServiceTarget {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_AUTH_SCHEME: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_AUTH_SCHEME: u8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_AUTH_SCHEME: [AuthScheme; 4] = [
  AuthScheme::None,
  AuthScheme::BearerToken,
  AuthScheme::MutualTLS,
  AuthScheme::ApiKey,
];

/// Authentication scheme in use for an inbound request.
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct AuthScheme(pub u8);
#[allow(non_upper_case_globals)]
impl AuthScheme {
  pub const None: Self = Self(0);
  pub const BearerToken: Self = Self(1);
  pub const MutualTLS: Self = Self(2);
  pub const ApiKey: Self = Self(3);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::None,
    Self::BearerToken,
    Self::MutualTLS,
    Self::ApiKey,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::None => Some("None"),
      Self::BearerToken => Some("BearerToken"),
      Self::MutualTLS => Some("MutualTLS"),
      Self::ApiKey => Some("ApiKey"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for AuthScheme {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for AuthScheme {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for AuthScheme {
    type Output = AuthScheme;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for AuthScheme {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for AuthScheme {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for AuthScheme {}
pub enum HeaderEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Compact HTTP header representation.
/// key_code is an internal enum value; value is the raw header bytes.
/// Avoids string key allocation on the hot-path.
pub struct HeaderEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HeaderEntry<'a> {
  type Inner = HeaderEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> HeaderEntry<'a> {
  pub const VT_KEY_CODE: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    HeaderEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args HeaderEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<HeaderEntry<'bldr>> {
    let mut builder = HeaderEntryBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    builder.add_key_code(args.key_code);
    builder.finish()
  }


  #[inline]
  pub fn key_code(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(HeaderEntry::VT_KEY_CODE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn value(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(HeaderEntry::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for HeaderEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("key_code", Self::VT_KEY_CODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct HeaderEntryArgs<'a> {
    pub key_code: u16,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for HeaderEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    HeaderEntryArgs {
      key_code: 0,
      value: None,
    }
  }
}

pub struct HeaderEntryBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HeaderEntryBuilder<'a, 'b> {
  #[inline]
  pub fn add_key_code(&mut self, key_code: u16) {
    self.fbb_.push_slot::<u16>(HeaderEntry::VT_KEY_CODE, key_code, 0);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HeaderEntry::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HeaderEntryBuilder<'a, 'b> {
    let start = _fbb.start_table();
    HeaderEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<HeaderEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for HeaderEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("HeaderEntry");
      ds.field("key_code", &self.key_code());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum GatewayRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Inbound gateway request.
/// path_hash is XXH3-64 of the URL path — never store raw URL strings in the message.
/// The domain_context enables the gateway to tag requests for downstream
/// threat-intelligence transfer and model routing (ADR-026 tier selection).
pub struct GatewayRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GatewayRequest<'a> {
  type Inner = GatewayRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GatewayRequest<'a> {
  pub const VT_REQUEST_ID: flatbuffers::VOffsetT = 4;
  pub const VT_METHOD: flatbuffers::VOffsetT = 6;
  pub const VT_PATH_HASH: flatbuffers::VOffsetT = 8;
  pub const VT_TARGET_SERVICE: flatbuffers::VOffsetT = 10;
  pub const VT_AUTH_SCHEME: flatbuffers::VOffsetT = 12;
  pub const VT_AUTH_TOKEN_DIGEST: flatbuffers::VOffsetT = 14;
  pub const VT_HEADERS: flatbuffers::VOffsetT = 16;
  pub const VT_BODY: flatbuffers::VOffsetT = 18;
  pub const VT_DOMAIN_CONTEXT: flatbuffers::VOffsetT = 20;
  pub const VT_PROVENANCE: flatbuffers::VOffsetT = 22;
  pub const VT_TIMESTAMP_NS: flatbuffers::VOffsetT = 24;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GatewayRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GatewayRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<GatewayRequest<'bldr>> {
    let mut builder = GatewayRequestBuilder::new(_fbb);
    builder.add_timestamp_ns(args.timestamp_ns);
    builder.add_path_hash(args.path_hash);
    builder.add_request_id(args.request_id);
    if let Some(x) = args.provenance { builder.add_provenance(x); }
    if let Some(x) = args.domain_context { builder.add_domain_context(x); }
    if let Some(x) = args.body { builder.add_body(x); }
    if let Some(x) = args.headers { builder.add_headers(x); }
    if let Some(x) = args.auth_token_digest { builder.add_auth_token_digest(x); }
    builder.add_auth_scheme(args.auth_scheme);
    builder.add_target_service(args.target_service);
    builder.add_method(args.method);
    builder.finish()
  }


  #[inline]
  pub fn request_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GatewayRequest::VT_REQUEST_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn method(&self) -> HttpMethod {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<HttpMethod>(GatewayRequest::VT_METHOD, Some(HttpMethod::GET)).unwrap()}
  }
  #[inline]
  pub fn path_hash(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GatewayRequest::VT_PATH_HASH, Some(0)).unwrap()}
  }
  #[inline]
  pub fn target_service(&self) -> ServiceTarget {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ServiceTarget>(GatewayRequest::VT_TARGET_SERVICE, Some(ServiceTarget::ShieldService)).unwrap()}
  }
  #[inline]
  pub fn auth_scheme(&self) -> AuthScheme {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<AuthScheme>(GatewayRequest::VT_AUTH_SCHEME, Some(AuthScheme::None)).unwrap()}
  }
  #[inline]
  pub fn auth_token_digest(&self) -> Option<&'a super::common::Xxh3Digest> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<super::common::Xxh3Digest>(GatewayRequest::VT_AUTH_TOKEN_DIGEST, None)}
  }
  #[inline]
  pub fn headers(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<HeaderEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<HeaderEntry>>>>(GatewayRequest::VT_HEADERS, None)}
  }
  #[inline]
  pub fn body(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(GatewayRequest::VT_BODY, None)}
  }
  #[inline]
  pub fn domain_context(&self) -> Option<super::common::DomainContext<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<super::common::DomainContext>>(GatewayRequest::VT_DOMAIN_CONTEXT, None)}
  }
  #[inline]
  pub fn provenance(&self) -> Option<super::common::ProvenanceRecord<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<super::common::ProvenanceRecord>>(GatewayRequest::VT_PROVENANCE, None)}
  }
  #[inline]
  pub fn timestamp_ns(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GatewayRequest::VT_TIMESTAMP_NS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for GatewayRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("request_id", Self::VT_REQUEST_ID, false)?
     .visit_field::<HttpMethod>("method", Self::VT_METHOD, false)?
     .visit_field::<u64>("path_hash", Self::VT_PATH_HASH, false)?
     .visit_field::<ServiceTarget>("target_service", Self::VT_TARGET_SERVICE, false)?
     .visit_field::<AuthScheme>("auth_scheme", Self::VT_AUTH_SCHEME, false)?
     .visit_field::<super::common::Xxh3Digest>("auth_token_digest", Self::VT_AUTH_TOKEN_DIGEST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<HeaderEntry>>>>("headers", Self::VT_HEADERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("body", Self::VT_BODY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<super::common::DomainContext>>("domain_context", Self::VT_DOMAIN_CONTEXT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<super::common::ProvenanceRecord>>("provenance", Self::VT_PROVENANCE, false)?
     .visit_field::<u64>("timestamp_ns", Self::VT_TIMESTAMP_NS, false)?
     .finish();
    Ok(())
  }
}
pub struct GatewayRequestArgs<'a> {
    pub request_id: u64,
    pub method: HttpMethod,
    pub path_hash: u64,
    pub target_service: ServiceTarget,
    pub auth_scheme: AuthScheme,
    pub auth_token_digest: Option<&'a super::common::Xxh3Digest>,
    pub headers: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<HeaderEntry<'a>>>>>,
    pub body: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub domain_context: Option<flatbuffers::WIPOffset<super::common::DomainContext<'a>>>,
    pub provenance: Option<flatbuffers::WIPOffset<super::common::ProvenanceRecord<'a>>>,
    pub timestamp_ns: u64,
}
impl<'a> Default for GatewayRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    GatewayRequestArgs {
      request_id: 0,
      method: HttpMethod::GET,
      path_hash: 0,
      target_service: ServiceTarget::ShieldService,
      auth_scheme: AuthScheme::None,
      auth_token_digest: None,
      headers: None,
      body: None,
      domain_context: None,
      provenance: None,
      timestamp_ns: 0,
    }
  }
}

pub struct GatewayRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GatewayRequestBuilder<'a, 'b> {
  #[inline]
  pub fn add_request_id(&mut self, request_id: u64) {
    self.fbb_.push_slot::<u64>(GatewayRequest::VT_REQUEST_ID, request_id, 0);
  }
  #[inline]
  pub fn add_method(&mut self, method: HttpMethod) {
    self.fbb_.push_slot::<HttpMethod>(GatewayRequest::VT_METHOD, method, HttpMethod::GET);
  }
  #[inline]
  pub fn add_path_hash(&mut self, path_hash: u64) {
    self.fbb_.push_slot::<u64>(GatewayRequest::VT_PATH_HASH, path_hash, 0);
  }
  #[inline]
  pub fn add_target_service(&mut self, target_service: ServiceTarget) {
    self.fbb_.push_slot::<ServiceTarget>(GatewayRequest::VT_TARGET_SERVICE, target_service, ServiceTarget::ShieldService);
  }
  #[inline]
  pub fn add_auth_scheme(&mut self, auth_scheme: AuthScheme) {
    self.fbb_.push_slot::<AuthScheme>(GatewayRequest::VT_AUTH_SCHEME, auth_scheme, AuthScheme::None);
  }
  #[inline]
  pub fn add_auth_token_digest(&mut self, auth_token_digest: &super::common::Xxh3Digest) {
    self.fbb_.push_slot_always::<&super::common::Xxh3Digest>(GatewayRequest::VT_AUTH_TOKEN_DIGEST, auth_token_digest);
  }
  #[inline]
  pub fn add_headers(&mut self, headers: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<HeaderEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GatewayRequest::VT_HEADERS, headers);
  }
  #[inline]
  pub fn add_body(&mut self, body: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GatewayRequest::VT_BODY, body);
  }
  #[inline]
  pub fn add_domain_context(&mut self, domain_context: flatbuffers::WIPOffset<super::common::DomainContext<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::common::DomainContext>>(GatewayRequest::VT_DOMAIN_CONTEXT, domain_context);
  }
  #[inline]
  pub fn add_provenance(&mut self, provenance: flatbuffers::WIPOffset<super::common::ProvenanceRecord<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::common::ProvenanceRecord>>(GatewayRequest::VT_PROVENANCE, provenance);
  }
  #[inline]
  pub fn add_timestamp_ns(&mut self, timestamp_ns: u64) {
    self.fbb_.push_slot::<u64>(GatewayRequest::VT_TIMESTAMP_NS, timestamp_ns, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GatewayRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GatewayRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GatewayRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GatewayRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GatewayRequest");
      ds.field("request_id", &self.request_id());
      ds.field("method", &self.method());
      ds.field("path_hash", &self.path_hash());
      ds.field("target_service", &self.target_service());
      ds.field("auth_scheme", &self.auth_scheme());
      ds.field("auth_token_digest", &self.auth_token_digest());
      ds.field("headers", &self.headers());
      ds.field("body", &self.body());
      ds.field("domain_context", &self.domain_context());
      ds.field("provenance", &self.provenance());
      ds.field("timestamp_ns", &self.timestamp_ns());
      ds.finish()
  }
}
pub enum GatewayResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Outbound gateway response.
/// status_code is the numeric HTTP status (200, 403, 429, etc.).
pub struct GatewayResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GatewayResponse<'a> {
  type Inner = GatewayResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GatewayResponse<'a> {
  pub const VT_REQUEST_ID: flatbuffers::VOffsetT = 4;
  pub const VT_STATUS_CODE: flatbuffers::VOffsetT = 6;
  pub const VT_STATUS: flatbuffers::VOffsetT = 8;
  pub const VT_HEADERS: flatbuffers::VOffsetT = 10;
  pub const VT_BODY: flatbuffers::VOffsetT = 12;
  pub const VT_DOMAIN_CONTEXT: flatbuffers::VOffsetT = 14;
  pub const VT_PROVENANCE: flatbuffers::VOffsetT = 16;
  pub const VT_PROCESSING_NS: flatbuffers::VOffsetT = 18;
  pub const VT_UPSTREAM_LATENCY_NS: flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GatewayResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GatewayResponseArgs<'args>
  ) -> flatbuffers::WIPOffset<GatewayResponse<'bldr>> {
    let mut builder = GatewayResponseBuilder::new(_fbb);
    builder.add_upstream_latency_ns(args.upstream_latency_ns);
    builder.add_processing_ns(args.processing_ns);
    builder.add_request_id(args.request_id);
    if let Some(x) = args.provenance { builder.add_provenance(x); }
    if let Some(x) = args.domain_context { builder.add_domain_context(x); }
    if let Some(x) = args.body { builder.add_body(x); }
    if let Some(x) = args.headers { builder.add_headers(x); }
    builder.add_status_code(args.status_code);
    builder.add_status(args.status);
    builder.finish()
  }


  #[inline]
  pub fn request_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GatewayResponse::VT_REQUEST_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn status_code(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(GatewayResponse::VT_STATUS_CODE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn status(&self) -> super::common::RequestStatus {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<super::common::RequestStatus>(GatewayResponse::VT_STATUS, Some(super::common::RequestStatus::Pending)).unwrap()}
  }
  #[inline]
  pub fn headers(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<HeaderEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<HeaderEntry>>>>(GatewayResponse::VT_HEADERS, None)}
  }
  #[inline]
  pub fn body(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(GatewayResponse::VT_BODY, None)}
  }
  #[inline]
  pub fn domain_context(&self) -> Option<super::common::DomainContext<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<super::common::DomainContext>>(GatewayResponse::VT_DOMAIN_CONTEXT, None)}
  }
  #[inline]
  pub fn provenance(&self) -> Option<super::common::ProvenanceRecord<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<super::common::ProvenanceRecord>>(GatewayResponse::VT_PROVENANCE, None)}
  }
  #[inline]
  pub fn processing_ns(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GatewayResponse::VT_PROCESSING_NS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn upstream_latency_ns(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GatewayResponse::VT_UPSTREAM_LATENCY_NS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for GatewayResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("request_id", Self::VT_REQUEST_ID, false)?
     .visit_field::<u16>("status_code", Self::VT_STATUS_CODE, false)?
     .visit_field::<super::common::RequestStatus>("status", Self::VT_STATUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<HeaderEntry>>>>("headers", Self::VT_HEADERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("body", Self::VT_BODY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<super::common::DomainContext>>("domain_context", Self::VT_DOMAIN_CONTEXT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<super::common::ProvenanceRecord>>("provenance", Self::VT_PROVENANCE, false)?
     .visit_field::<u64>("processing_ns", Self::VT_PROCESSING_NS, false)?
     .visit_field::<u64>("upstream_latency_ns", Self::VT_UPSTREAM_LATENCY_NS, false)?
     .finish();
    Ok(())
  }
}
pub struct GatewayResponseArgs<'a> {
    pub request_id: u64,
    pub status_code: u16,
    pub status: super::common::RequestStatus,
    pub headers: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<HeaderEntry<'a>>>>>,
    pub body: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub domain_context: Option<flatbuffers::WIPOffset<super::common::DomainContext<'a>>>,
    pub provenance: Option<flatbuffers::WIPOffset<super::common::ProvenanceRecord<'a>>>,
    pub processing_ns: u64,
    pub upstream_latency_ns: u64,
}
impl<'a> Default for GatewayResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    GatewayResponseArgs {
      request_id: 0,
      status_code: 0,
      status: super::common::RequestStatus::Pending,
      headers: None,
      body: None,
      domain_context: None,
      provenance: None,
      processing_ns: 0,
      upstream_latency_ns: 0,
    }
  }
}

pub struct GatewayResponseBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GatewayResponseBuilder<'a, 'b> {
  #[inline]
  pub fn add_request_id(&mut self, request_id: u64) {
    self.fbb_.push_slot::<u64>(GatewayResponse::VT_REQUEST_ID, request_id, 0);
  }
  #[inline]
  pub fn add_status_code(&mut self, status_code: u16) {
    self.fbb_.push_slot::<u16>(GatewayResponse::VT_STATUS_CODE, status_code, 0);
  }
  #[inline]
  pub fn add_status(&mut self, status: super::common::RequestStatus) {
    self.fbb_.push_slot::<super::common::RequestStatus>(GatewayResponse::VT_STATUS, status, super::common::RequestStatus::Pending);
  }
  #[inline]
  pub fn add_headers(&mut self, headers: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<HeaderEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GatewayResponse::VT_HEADERS, headers);
  }
  #[inline]
  pub fn add_body(&mut self, body: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GatewayResponse::VT_BODY, body);
  }
  #[inline]
  pub fn add_domain_context(&mut self, domain_context: flatbuffers::WIPOffset<super::common::DomainContext<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::common::DomainContext>>(GatewayResponse::VT_DOMAIN_CONTEXT, domain_context);
  }
  #[inline]
  pub fn add_provenance(&mut self, provenance: flatbuffers::WIPOffset<super::common::ProvenanceRecord<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::common::ProvenanceRecord>>(GatewayResponse::VT_PROVENANCE, provenance);
  }
  #[inline]
  pub fn add_processing_ns(&mut self, processing_ns: u64) {
    self.fbb_.push_slot::<u64>(GatewayResponse::VT_PROCESSING_NS, processing_ns, 0);
  }
  #[inline]
  pub fn add_upstream_latency_ns(&mut self, upstream_latency_ns: u64) {
    self.fbb_.push_slot::<u64>(GatewayResponse::VT_UPSTREAM_LATENCY_NS, upstream_latency_ns, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GatewayResponseBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GatewayResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GatewayResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GatewayResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GatewayResponse");
      ds.field("request_id", &self.request_id());
      ds.field("status_code", &self.status_code());
      ds.field("status", &self.status());
      ds.field("headers", &self.headers());
      ds.field("body", &self.body());
      ds.field("domain_context", &self.domain_context());
      ds.field("provenance", &self.provenance());
      ds.field("processing_ns", &self.processing_ns());
      ds.field("upstream_latency_ns", &self.upstream_latency_ns());
      ds.finish()
  }
}
pub enum RouteConfigOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Routing configuration for a service target.
/// tier encodes the ADR-026 3-tier model routing decision:
///   1 = WASM Booster (<1 ms, no LLM)
///   2 = Haiku        (~500 ms, simple tasks)
///   3 = Sonnet/Opus  (2–5 s, complex reasoning)
pub struct RouteConfig<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RouteConfig<'a> {
  type Inner = RouteConfig<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RouteConfig<'a> {
  pub const VT_SERVICE: flatbuffers::VOffsetT = 4;
  pub const VT_TIER: flatbuffers::VOffsetT = 6;
  pub const VT_TIMEOUT_NS: flatbuffers::VOffsetT = 8;
  pub const VT_MAX_RETRIES: flatbuffers::VOffsetT = 10;
  pub const VT_CIRCUIT_BREAK_THRESHOLD: flatbuffers::VOffsetT = 12;
  pub const VT_DOMAIN_CONTEXT: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RouteConfig { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RouteConfigArgs<'args>
  ) -> flatbuffers::WIPOffset<RouteConfig<'bldr>> {
    let mut builder = RouteConfigBuilder::new(_fbb);
    builder.add_timeout_ns(args.timeout_ns);
    if let Some(x) = args.domain_context { builder.add_domain_context(x); }
    builder.add_circuit_break_threshold(args.circuit_break_threshold);
    builder.add_max_retries(args.max_retries);
    builder.add_tier(args.tier);
    builder.add_service(args.service);
    builder.finish()
  }


  #[inline]
  pub fn service(&self) -> ServiceTarget {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ServiceTarget>(RouteConfig::VT_SERVICE, Some(ServiceTarget::ShieldService)).unwrap()}
  }
  #[inline]
  pub fn tier(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(RouteConfig::VT_TIER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn timeout_ns(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(RouteConfig::VT_TIMEOUT_NS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn max_retries(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(RouteConfig::VT_MAX_RETRIES, Some(0)).unwrap()}
  }
  #[inline]
  pub fn circuit_break_threshold(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(RouteConfig::VT_CIRCUIT_BREAK_THRESHOLD, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn domain_context(&self) -> Option<super::common::DomainContext<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<super::common::DomainContext>>(RouteConfig::VT_DOMAIN_CONTEXT, None)}
  }
}

impl flatbuffers::Verifiable for RouteConfig<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<ServiceTarget>("service", Self::VT_SERVICE, false)?
     .visit_field::<u8>("tier", Self::VT_TIER, false)?
     .visit_field::<u64>("timeout_ns", Self::VT_TIMEOUT_NS, false)?
     .visit_field::<u8>("max_retries", Self::VT_MAX_RETRIES, false)?
     .visit_field::<f32>("circuit_break_threshold", Self::VT_CIRCUIT_BREAK_THRESHOLD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<super::common::DomainContext>>("domain_context", Self::VT_DOMAIN_CONTEXT, false)?
     .finish();
    Ok(())
  }
}
pub struct RouteConfigArgs<'a> {
    pub service: ServiceTarget,
    pub tier: u8,
    pub timeout_ns: u64,
    pub max_retries: u8,
    pub circuit_break_threshold: f32,
    pub domain_context: Option<flatbuffers::WIPOffset<super::common::DomainContext<'a>>>,
}
impl<'a> Default for RouteConfigArgs<'a> {
  #[inline]
  fn default() -> Self {
    RouteConfigArgs {
      service: ServiceTarget::ShieldService,
      tier: 0,
      timeout_ns: 0,
      max_retries: 0,
      circuit_break_threshold: 0.0,
      domain_context: None,
    }
  }
}

pub struct RouteConfigBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RouteConfigBuilder<'a, 'b> {
  #[inline]
  pub fn add_service(&mut self, service: ServiceTarget) {
    self.fbb_.push_slot::<ServiceTarget>(RouteConfig::VT_SERVICE, service, ServiceTarget::ShieldService);
  }
  #[inline]
  pub fn add_tier(&mut self, tier: u8) {
    self.fbb_.push_slot::<u8>(RouteConfig::VT_TIER, tier, 0);
  }
  #[inline]
  pub fn add_timeout_ns(&mut self, timeout_ns: u64) {
    self.fbb_.push_slot::<u64>(RouteConfig::VT_TIMEOUT_NS, timeout_ns, 0);
  }
  #[inline]
  pub fn add_max_retries(&mut self, max_retries: u8) {
    self.fbb_.push_slot::<u8>(RouteConfig::VT_MAX_RETRIES, max_retries, 0);
  }
  #[inline]
  pub fn add_circuit_break_threshold(&mut self, circuit_break_threshold: f32) {
    self.fbb_.push_slot::<f32>(RouteConfig::VT_CIRCUIT_BREAK_THRESHOLD, circuit_break_threshold, 0.0);
  }
  #[inline]
  pub fn add_domain_context(&mut self, domain_context: flatbuffers::WIPOffset<super::common::DomainContext<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::common::DomainContext>>(RouteConfig::VT_DOMAIN_CONTEXT, domain_context);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RouteConfigBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RouteConfigBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RouteConfig<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RouteConfig<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RouteConfig");
      ds.field("service", &self.service());
      ds.field("tier", &self.tier());
      ds.field("timeout_ns", &self.timeout_ns());
      ds.field("max_retries", &self.max_retries());
      ds.field("circuit_break_threshold", &self.circuit_break_threshold());
      ds.field("domain_context", &self.domain_context());
      ds.finish()
  }
}
pub enum RateLimitEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Rate-limit ledger entry keyed by client fingerprint.
/// client_fingerprint is XXH3-128 of (IP ‖ auth_token_digest) — no PII string stored.
pub struct RateLimitEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RateLimitEntry<'a> {
  type Inner = RateLimitEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RateLimitEntry<'a> {
  pub const VT_CLIENT_FINGERPRINT: flatbuffers::VOffsetT = 4;
  pub const VT_WINDOW_START_NS: flatbuffers::VOffsetT = 6;
  pub const VT_REQUEST_COUNT: flatbuffers::VOffsetT = 8;
  pub const VT_MAX_REQUESTS: flatbuffers::VOffsetT = 10;
  pub const VT_BLOCKED: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RateLimitEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RateLimitEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<RateLimitEntry<'bldr>> {
    let mut builder = RateLimitEntryBuilder::new(_fbb);
    builder.add_window_start_ns(args.window_start_ns);
    builder.add_max_requests(args.max_requests);
    builder.add_request_count(args.request_count);
    if let Some(x) = args.client_fingerprint { builder.add_client_fingerprint(x); }
    builder.add_blocked(args.blocked);
    builder.finish()
  }


  #[inline]
  pub fn client_fingerprint(&self) -> Option<&'a super::common::Xxh3Digest> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<super::common::Xxh3Digest>(RateLimitEntry::VT_CLIENT_FINGERPRINT, None)}
  }
  #[inline]
  pub fn window_start_ns(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(RateLimitEntry::VT_WINDOW_START_NS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn request_count(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(RateLimitEntry::VT_REQUEST_COUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn max_requests(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(RateLimitEntry::VT_MAX_REQUESTS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn blocked(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(RateLimitEntry::VT_BLOCKED, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for RateLimitEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<super::common::Xxh3Digest>("client_fingerprint", Self::VT_CLIENT_FINGERPRINT, false)?
     .visit_field::<u64>("window_start_ns", Self::VT_WINDOW_START_NS, false)?
     .visit_field::<u32>("request_count", Self::VT_REQUEST_COUNT, false)?
     .visit_field::<u32>("max_requests", Self::VT_MAX_REQUESTS, false)?
     .visit_field::<bool>("blocked", Self::VT_BLOCKED, false)?
     .finish();
    Ok(())
  }
}
pub struct RateLimitEntryArgs<'a> {
    pub client_fingerprint: Option<&'a super::common::Xxh3Digest>,
    pub window_start_ns: u64,
    pub request_count: u32,
    pub max_requests: u32,
    pub blocked: bool,
}
impl<'a> Default for RateLimitEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    RateLimitEntryArgs {
      client_fingerprint: None,
      window_start_ns: 0,
      request_count: 0,
      max_requests: 0,
      blocked: false,
    }
  }
}

pub struct RateLimitEntryBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RateLimitEntryBuilder<'a, 'b> {
  #[inline]
  pub fn add_client_fingerprint(&mut self, client_fingerprint: &super::common::Xxh3Digest) {
    self.fbb_.push_slot_always::<&super::common::Xxh3Digest>(RateLimitEntry::VT_CLIENT_FINGERPRINT, client_fingerprint);
  }
  #[inline]
  pub fn add_window_start_ns(&mut self, window_start_ns: u64) {
    self.fbb_.push_slot::<u64>(RateLimitEntry::VT_WINDOW_START_NS, window_start_ns, 0);
  }
  #[inline]
  pub fn add_request_count(&mut self, request_count: u32) {
    self.fbb_.push_slot::<u32>(RateLimitEntry::VT_REQUEST_COUNT, request_count, 0);
  }
  #[inline]
  pub fn add_max_requests(&mut self, max_requests: u32) {
    self.fbb_.push_slot::<u32>(RateLimitEntry::VT_MAX_REQUESTS, max_requests, 0);
  }
  #[inline]
  pub fn add_blocked(&mut self, blocked: bool) {
    self.fbb_.push_slot::<bool>(RateLimitEntry::VT_BLOCKED, blocked, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RateLimitEntryBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RateLimitEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RateLimitEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RateLimitEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RateLimitEntry");
      ds.field("client_fingerprint", &self.client_fingerprint());
      ds.field("window_start_ns", &self.window_start_ns());
      ds.field("request_count", &self.request_count());
      ds.field("max_requests", &self.max_requests());
      ds.field("blocked", &self.blocked());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `GatewayRequest`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_gateway_request_unchecked`.
pub fn root_as_gateway_request(buf: &[u8]) -> Result<GatewayRequest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<GatewayRequest>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `GatewayRequest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_gateway_request_unchecked`.
pub fn size_prefixed_root_as_gateway_request(buf: &[u8]) -> Result<GatewayRequest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<GatewayRequest>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `GatewayRequest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_gateway_request_unchecked`.
pub fn root_as_gateway_request_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<GatewayRequest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<GatewayRequest<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `GatewayRequest` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_gateway_request_unchecked`.
pub fn size_prefixed_root_as_gateway_request_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<GatewayRequest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<GatewayRequest<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a GatewayRequest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `GatewayRequest`.
pub unsafe fn root_as_gateway_request_unchecked(buf: &[u8]) -> GatewayRequest {
  flatbuffers::root_unchecked::<GatewayRequest>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed GatewayRequest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `GatewayRequest`.
pub unsafe fn size_prefixed_root_as_gateway_request_unchecked(buf: &[u8]) -> GatewayRequest {
  flatbuffers::size_prefixed_root_unchecked::<GatewayRequest>(buf)
}
#[inline]
pub fn finish_gateway_request_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<GatewayRequest<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_gateway_request_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<GatewayRequest<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod gateway
}  // pub mod mothership

