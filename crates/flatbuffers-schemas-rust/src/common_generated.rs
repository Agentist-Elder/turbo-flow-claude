// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod mothership {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod common {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SYSTEM_ID: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SYSTEM_ID: u8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SYSTEM_ID: [SystemId; 4] = [
  SystemId::Unknown,
  SystemId::WasmSecurityGate,
  SystemId::UnixAdaptiveSentinel,
  SystemId::L3ApiGateway,
];

/// Identifies which system produced or consumed a message.
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SystemId(pub u8);
#[allow(non_upper_case_globals)]
impl SystemId {
  pub const Unknown: Self = Self(0);
  pub const WasmSecurityGate: Self = Self(1);
  pub const UnixAdaptiveSentinel: Self = Self(2);
  pub const L3ApiGateway: Self = Self(3);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Unknown,
    Self::WasmSecurityGate,
    Self::UnixAdaptiveSentinel,
    Self::L3ApiGateway,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Unknown => Some("Unknown"),
      Self::WasmSecurityGate => Some("WasmSecurityGate"),
      Self::UnixAdaptiveSentinel => Some("UnixAdaptiveSentinel"),
      Self::L3ApiGateway => Some("L3ApiGateway"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for SystemId {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SystemId {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for SystemId {
    type Output = SystemId;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SystemId {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SystemId {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SystemId {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_THREAT_LEVEL: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_THREAT_LEVEL: u8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_THREAT_LEVEL: [ThreatLevel; 5] = [
  ThreatLevel::None,
  ThreatLevel::Low,
  ThreatLevel::Medium,
  ThreatLevel::High,
  ThreatLevel::Critical,
];

/// Severity classification for threats and policy decisions.
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ThreatLevel(pub u8);
#[allow(non_upper_case_globals)]
impl ThreatLevel {
  pub const None: Self = Self(0);
  pub const Low: Self = Self(1);
  pub const Medium: Self = Self(2);
  pub const High: Self = Self(3);
  pub const Critical: Self = Self(4);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::None,
    Self::Low,
    Self::Medium,
    Self::High,
    Self::Critical,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::None => Some("None"),
      Self::Low => Some("Low"),
      Self::Medium => Some("Medium"),
      Self::High => Some("High"),
      Self::Critical => Some("Critical"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ThreatLevel {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ThreatLevel {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ThreatLevel {
    type Output = ThreatLevel;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ThreatLevel {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ThreatLevel {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ThreatLevel {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_REQUEST_STATUS: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_REQUEST_STATUS: u8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_REQUEST_STATUS: [RequestStatus; 5] = [
  RequestStatus::Pending,
  RequestStatus::Approved,
  RequestStatus::Denied,
  RequestStatus::Escalated,
  RequestStatus::Timeout,
];

/// Outcome status for RPC calls and gateway responses.
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct RequestStatus(pub u8);
#[allow(non_upper_case_globals)]
impl RequestStatus {
  pub const Pending: Self = Self(0);
  pub const Approved: Self = Self(1);
  pub const Denied: Self = Self(2);
  pub const Escalated: Self = Self(3);
  pub const Timeout: Self = Self(4);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Pending,
    Self::Approved,
    Self::Denied,
    Self::Escalated,
    Self::Timeout,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Pending => Some("Pending"),
      Self::Approved => Some("Approved"),
      Self::Denied => Some("Denied"),
      Self::Escalated => Some("Escalated"),
      Self::Timeout => Some("Timeout"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for RequestStatus {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for RequestStatus {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for RequestStatus {
    type Output = RequestStatus;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for RequestStatus {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for RequestStatus {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for RequestStatus {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TRANSPORT_ENCODING: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TRANSPORT_ENCODING: u8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TRANSPORT_ENCODING: [TransportEncoding; 2] = [
  TransportEncoding::FlatBuffers,
  TransportEncoding::MessagePack,
];

/// Serialisation format used at a boundary crossing.
/// JSON is strictly forbidden at the WASM/Unix boundary (ADR-026).
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TransportEncoding(pub u8);
#[allow(non_upper_case_globals)]
impl TransportEncoding {
  pub const FlatBuffers: Self = Self(0);
  pub const MessagePack: Self = Self(1);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::FlatBuffers,
    Self::MessagePack,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::FlatBuffers => Some("FlatBuffers"),
      Self::MessagePack => Some("MessagePack"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for TransportEncoding {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for TransportEncoding {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for TransportEncoding {
    type Output = TransportEncoding;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for TransportEncoding {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for TransportEncoding {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for TransportEncoding {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DOMAIN_ID: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DOMAIN_ID: u8 = 8;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DOMAIN_ID: [DomainId; 9] = [
  DomainId::Unknown,
  DomainId::FinancialTransactions,
  DomainId::ThreatIntelligence,
  DomainId::NetworkSecurity,
  DomainId::DataExfiltration,
  DomainId::SocialEngineering,
  DomainId::MalwareSignatures,
  DomainId::PrivilegeEscalation,
  DomainId::SupplyChain,
];

/// Semantic domain identifier — used for cross-domain threat-intel transfer.
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DomainId(pub u8);
#[allow(non_upper_case_globals)]
impl DomainId {
  pub const Unknown: Self = Self(0);
  pub const FinancialTransactions: Self = Self(1);
  pub const ThreatIntelligence: Self = Self(2);
  pub const NetworkSecurity: Self = Self(3);
  pub const DataExfiltration: Self = Self(4);
  pub const SocialEngineering: Self = Self(5);
  pub const MalwareSignatures: Self = Self(6);
  pub const PrivilegeEscalation: Self = Self(7);
  pub const SupplyChain: Self = Self(8);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 8;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Unknown,
    Self::FinancialTransactions,
    Self::ThreatIntelligence,
    Self::NetworkSecurity,
    Self::DataExfiltration,
    Self::SocialEngineering,
    Self::MalwareSignatures,
    Self::PrivilegeEscalation,
    Self::SupplyChain,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Unknown => Some("Unknown"),
      Self::FinancialTransactions => Some("FinancialTransactions"),
      Self::ThreatIntelligence => Some("ThreatIntelligence"),
      Self::NetworkSecurity => Some("NetworkSecurity"),
      Self::DataExfiltration => Some("DataExfiltration"),
      Self::SocialEngineering => Some("SocialEngineering"),
      Self::MalwareSignatures => Some("MalwareSignatures"),
      Self::PrivilegeEscalation => Some("PrivilegeEscalation"),
      Self::SupplyChain => Some("SupplyChain"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DomainId {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DomainId {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for DomainId {
    type Output = DomainId;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DomainId {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DomainId {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DomainId {}
/// XXH3-128 content digest (16 bytes).
// struct Xxh3Digest, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Xxh3Digest(pub [u8; 16]);
impl Default for Xxh3Digest { 
  fn default() -> Self { 
    Self([0; 16])
  }
}
impl core::fmt::Debug for Xxh3Digest {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Xxh3Digest")
      .field("lo", &self.lo())
      .field("hi", &self.hi())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Xxh3Digest {}
impl<'a> flatbuffers::Follow<'a> for Xxh3Digest {
  type Inner = &'a Xxh3Digest;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Xxh3Digest>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Xxh3Digest {
  type Inner = &'a Xxh3Digest;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Xxh3Digest>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Xxh3Digest {
    type Output = Xxh3Digest;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Xxh3Digest as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Xxh3Digest {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Xxh3Digest {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    lo: u64,
    hi: u64,
  ) -> Self {
    let mut s = Self([0; 16]);
    s.set_lo(lo);
    s.set_hi(hi);
    s
  }

  pub fn lo(&self) -> u64 {
    let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_lo(&mut self, x: u64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn hi(&self) -> u64 {
    let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[8..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_hi(&mut self, x: u64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[8..].as_mut_ptr(),
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
    }
  }

}

/// ED25519 public key (32 bytes = 4 × uint64).
/// Vulnerability flag: do NOT use XXH3 alone for origin verification;
/// this key authenticates the originating system via ED25519.
// struct Ed25519PublicKey, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Ed25519PublicKey(pub [u8; 32]);
impl Default for Ed25519PublicKey { 
  fn default() -> Self { 
    Self([0; 32])
  }
}
impl core::fmt::Debug for Ed25519PublicKey {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Ed25519PublicKey")
      .field("b0", &self.b0())
      .field("b1", &self.b1())
      .field("b2", &self.b2())
      .field("b3", &self.b3())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Ed25519PublicKey {}
impl<'a> flatbuffers::Follow<'a> for Ed25519PublicKey {
  type Inner = &'a Ed25519PublicKey;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Ed25519PublicKey>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Ed25519PublicKey {
  type Inner = &'a Ed25519PublicKey;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Ed25519PublicKey>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Ed25519PublicKey {
    type Output = Ed25519PublicKey;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Ed25519PublicKey as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Ed25519PublicKey {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Ed25519PublicKey {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    b0: u64,
    b1: u64,
    b2: u64,
    b3: u64,
  ) -> Self {
    let mut s = Self([0; 32]);
    s.set_b0(b0);
    s.set_b1(b1);
    s.set_b2(b2);
    s.set_b3(b3);
    s
  }

  pub fn b0(&self) -> u64 {
    let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_b0(&mut self, x: u64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn b1(&self) -> u64 {
    let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[8..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_b1(&mut self, x: u64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[8..].as_mut_ptr(),
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn b2(&self) -> u64 {
    let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[16..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_b2(&mut self, x: u64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[16..].as_mut_ptr(),
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn b3(&self) -> u64 {
    let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[24..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_b3(&mut self, x: u64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[24..].as_mut_ptr(),
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
    }
  }

}

/// ED25519 signature over (content_digest ‖ timestamp_ns) (64 bytes = 8 × uint64).
/// Required on every provenance-bearing message per Ruv security advisory.
// struct Ed25519Signature, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Ed25519Signature(pub [u8; 64]);
impl Default for Ed25519Signature { 
  fn default() -> Self { 
    Self([0; 64])
  }
}
impl core::fmt::Debug for Ed25519Signature {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Ed25519Signature")
      .field("b0", &self.b0())
      .field("b1", &self.b1())
      .field("b2", &self.b2())
      .field("b3", &self.b3())
      .field("b4", &self.b4())
      .field("b5", &self.b5())
      .field("b6", &self.b6())
      .field("b7", &self.b7())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Ed25519Signature {}
impl<'a> flatbuffers::Follow<'a> for Ed25519Signature {
  type Inner = &'a Ed25519Signature;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Ed25519Signature>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Ed25519Signature {
  type Inner = &'a Ed25519Signature;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Ed25519Signature>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Ed25519Signature {
    type Output = Ed25519Signature;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Ed25519Signature as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Ed25519Signature {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Ed25519Signature {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    b0: u64,
    b1: u64,
    b2: u64,
    b3: u64,
    b4: u64,
    b5: u64,
    b6: u64,
    b7: u64,
  ) -> Self {
    let mut s = Self([0; 64]);
    s.set_b0(b0);
    s.set_b1(b1);
    s.set_b2(b2);
    s.set_b3(b3);
    s.set_b4(b4);
    s.set_b5(b5);
    s.set_b6(b6);
    s.set_b7(b7);
    s
  }

  pub fn b0(&self) -> u64 {
    let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_b0(&mut self, x: u64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn b1(&self) -> u64 {
    let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[8..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_b1(&mut self, x: u64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[8..].as_mut_ptr(),
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn b2(&self) -> u64 {
    let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[16..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_b2(&mut self, x: u64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[16..].as_mut_ptr(),
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn b3(&self) -> u64 {
    let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[24..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_b3(&mut self, x: u64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[24..].as_mut_ptr(),
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn b4(&self) -> u64 {
    let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[32..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_b4(&mut self, x: u64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[32..].as_mut_ptr(),
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn b5(&self) -> u64 {
    let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[40..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_b5(&mut self, x: u64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[40..].as_mut_ptr(),
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn b6(&self) -> u64 {
    let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[48..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_b6(&mut self, x: u64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[48..].as_mut_ptr(),
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn b7(&self) -> u64 {
    let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[56..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_b7(&mut self, x: u64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[56..].as_mut_ptr(),
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
    }
  }

}

pub enum ProvenanceRecordOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Cryptographic provenance record — attaches to every artifact and state change.
/// The signature authenticates the XXH3 content digest; the post-quantum wrapper
/// is applied at the pq-wrap transport layer and is not repeated here.
pub struct ProvenanceRecord<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ProvenanceRecord<'a> {
  type Inner = ProvenanceRecord<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ProvenanceRecord<'a> {
  pub const VT_ORIGIN_SYSTEM: flatbuffers::VOffsetT = 4;
  pub const VT_CONTENT_DIGEST: flatbuffers::VOffsetT = 6;
  pub const VT_SIGNATURE: flatbuffers::VOffsetT = 8;
  pub const VT_PUBLIC_KEY: flatbuffers::VOffsetT = 10;
  pub const VT_TIMESTAMP_NS: flatbuffers::VOffsetT = 12;
  pub const VT_WITNESS_CHAIN_HEIGHT: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ProvenanceRecord { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ProvenanceRecordArgs<'args>
  ) -> flatbuffers::WIPOffset<ProvenanceRecord<'bldr>> {
    let mut builder = ProvenanceRecordBuilder::new(_fbb);
    builder.add_witness_chain_height(args.witness_chain_height);
    builder.add_timestamp_ns(args.timestamp_ns);
    if let Some(x) = args.public_key { builder.add_public_key(x); }
    if let Some(x) = args.signature { builder.add_signature(x); }
    if let Some(x) = args.content_digest { builder.add_content_digest(x); }
    builder.add_origin_system(args.origin_system);
    builder.finish()
  }


  #[inline]
  pub fn origin_system(&self) -> SystemId {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<SystemId>(ProvenanceRecord::VT_ORIGIN_SYSTEM, Some(SystemId::Unknown)).unwrap()}
  }
  #[inline]
  pub fn content_digest(&self) -> Option<&'a Xxh3Digest> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Xxh3Digest>(ProvenanceRecord::VT_CONTENT_DIGEST, None)}
  }
  #[inline]
  pub fn signature(&self) -> Option<&'a Ed25519Signature> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Ed25519Signature>(ProvenanceRecord::VT_SIGNATURE, None)}
  }
  #[inline]
  pub fn public_key(&self) -> Option<&'a Ed25519PublicKey> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Ed25519PublicKey>(ProvenanceRecord::VT_PUBLIC_KEY, None)}
  }
  #[inline]
  pub fn timestamp_ns(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ProvenanceRecord::VT_TIMESTAMP_NS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn witness_chain_height(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ProvenanceRecord::VT_WITNESS_CHAIN_HEIGHT, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ProvenanceRecord<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<SystemId>("origin_system", Self::VT_ORIGIN_SYSTEM, false)?
     .visit_field::<Xxh3Digest>("content_digest", Self::VT_CONTENT_DIGEST, false)?
     .visit_field::<Ed25519Signature>("signature", Self::VT_SIGNATURE, false)?
     .visit_field::<Ed25519PublicKey>("public_key", Self::VT_PUBLIC_KEY, false)?
     .visit_field::<u64>("timestamp_ns", Self::VT_TIMESTAMP_NS, false)?
     .visit_field::<u64>("witness_chain_height", Self::VT_WITNESS_CHAIN_HEIGHT, false)?
     .finish();
    Ok(())
  }
}
pub struct ProvenanceRecordArgs<'a> {
    pub origin_system: SystemId,
    pub content_digest: Option<&'a Xxh3Digest>,
    pub signature: Option<&'a Ed25519Signature>,
    pub public_key: Option<&'a Ed25519PublicKey>,
    pub timestamp_ns: u64,
    pub witness_chain_height: u64,
}
impl<'a> Default for ProvenanceRecordArgs<'a> {
  #[inline]
  fn default() -> Self {
    ProvenanceRecordArgs {
      origin_system: SystemId::Unknown,
      content_digest: None,
      signature: None,
      public_key: None,
      timestamp_ns: 0,
      witness_chain_height: 0,
    }
  }
}

pub struct ProvenanceRecordBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ProvenanceRecordBuilder<'a, 'b> {
  #[inline]
  pub fn add_origin_system(&mut self, origin_system: SystemId) {
    self.fbb_.push_slot::<SystemId>(ProvenanceRecord::VT_ORIGIN_SYSTEM, origin_system, SystemId::Unknown);
  }
  #[inline]
  pub fn add_content_digest(&mut self, content_digest: &Xxh3Digest) {
    self.fbb_.push_slot_always::<&Xxh3Digest>(ProvenanceRecord::VT_CONTENT_DIGEST, content_digest);
  }
  #[inline]
  pub fn add_signature(&mut self, signature: &Ed25519Signature) {
    self.fbb_.push_slot_always::<&Ed25519Signature>(ProvenanceRecord::VT_SIGNATURE, signature);
  }
  #[inline]
  pub fn add_public_key(&mut self, public_key: &Ed25519PublicKey) {
    self.fbb_.push_slot_always::<&Ed25519PublicKey>(ProvenanceRecord::VT_PUBLIC_KEY, public_key);
  }
  #[inline]
  pub fn add_timestamp_ns(&mut self, timestamp_ns: u64) {
    self.fbb_.push_slot::<u64>(ProvenanceRecord::VT_TIMESTAMP_NS, timestamp_ns, 0);
  }
  #[inline]
  pub fn add_witness_chain_height(&mut self, witness_chain_height: u64) {
    self.fbb_.push_slot::<u64>(ProvenanceRecord::VT_WITNESS_CHAIN_HEIGHT, witness_chain_height, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ProvenanceRecordBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ProvenanceRecordBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ProvenanceRecord<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ProvenanceRecord<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ProvenanceRecord");
      ds.field("origin_system", &self.origin_system());
      ds.field("content_digest", &self.content_digest());
      ds.field("signature", &self.signature());
      ds.field("public_key", &self.public_key());
      ds.field("timestamp_ns", &self.timestamp_ns());
      ds.field("witness_chain_height", &self.witness_chain_height());
      ds.finish()
  }
}
pub enum DomainContextOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Domain-expansion context — enables ruvector LoRA transfer between semantic domains.
/// The embedding vector (768-dim, float32, ONNX space) drives cosine similarity routing.
/// Pi-derived quantisation: callers MUST scale threshold comparisons by π to prevent
/// binary harmonic resonance drift in continuous deterministic memory.
pub struct DomainContext<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DomainContext<'a> {
  type Inner = DomainContext<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DomainContext<'a> {
  pub const VT_SOURCE_DOMAIN: flatbuffers::VOffsetT = 4;
  pub const VT_TARGET_DOMAIN: flatbuffers::VOffsetT = 6;
  pub const VT_EMBEDDING: flatbuffers::VOffsetT = 8;
  pub const VT_CONFIDENCE: flatbuffers::VOffsetT = 10;
  pub const VT_TRANSFER_SCORE: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DomainContext { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DomainContextArgs<'args>
  ) -> flatbuffers::WIPOffset<DomainContext<'bldr>> {
    let mut builder = DomainContextBuilder::new(_fbb);
    builder.add_transfer_score(args.transfer_score);
    builder.add_confidence(args.confidence);
    if let Some(x) = args.embedding { builder.add_embedding(x); }
    builder.add_target_domain(args.target_domain);
    builder.add_source_domain(args.source_domain);
    builder.finish()
  }


  #[inline]
  pub fn source_domain(&self) -> DomainId {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DomainId>(DomainContext::VT_SOURCE_DOMAIN, Some(DomainId::Unknown)).unwrap()}
  }
  #[inline]
  pub fn target_domain(&self) -> DomainId {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DomainId>(DomainContext::VT_TARGET_DOMAIN, Some(DomainId::Unknown)).unwrap()}
  }
  #[inline]
  pub fn embedding(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(DomainContext::VT_EMBEDDING, None)}
  }
  #[inline]
  pub fn confidence(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DomainContext::VT_CONFIDENCE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn transfer_score(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DomainContext::VT_TRANSFER_SCORE, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DomainContext<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<DomainId>("source_domain", Self::VT_SOURCE_DOMAIN, false)?
     .visit_field::<DomainId>("target_domain", Self::VT_TARGET_DOMAIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>("embedding", Self::VT_EMBEDDING, false)?
     .visit_field::<f32>("confidence", Self::VT_CONFIDENCE, false)?
     .visit_field::<f32>("transfer_score", Self::VT_TRANSFER_SCORE, false)?
     .finish();
    Ok(())
  }
}
pub struct DomainContextArgs<'a> {
    pub source_domain: DomainId,
    pub target_domain: DomainId,
    pub embedding: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub confidence: f32,
    pub transfer_score: f32,
}
impl<'a> Default for DomainContextArgs<'a> {
  #[inline]
  fn default() -> Self {
    DomainContextArgs {
      source_domain: DomainId::Unknown,
      target_domain: DomainId::Unknown,
      embedding: None,
      confidence: 0.0,
      transfer_score: 0.0,
    }
  }
}

pub struct DomainContextBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DomainContextBuilder<'a, 'b> {
  #[inline]
  pub fn add_source_domain(&mut self, source_domain: DomainId) {
    self.fbb_.push_slot::<DomainId>(DomainContext::VT_SOURCE_DOMAIN, source_domain, DomainId::Unknown);
  }
  #[inline]
  pub fn add_target_domain(&mut self, target_domain: DomainId) {
    self.fbb_.push_slot::<DomainId>(DomainContext::VT_TARGET_DOMAIN, target_domain, DomainId::Unknown);
  }
  #[inline]
  pub fn add_embedding(&mut self, embedding: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DomainContext::VT_EMBEDDING, embedding);
  }
  #[inline]
  pub fn add_confidence(&mut self, confidence: f32) {
    self.fbb_.push_slot::<f32>(DomainContext::VT_CONFIDENCE, confidence, 0.0);
  }
  #[inline]
  pub fn add_transfer_score(&mut self, transfer_score: f32) {
    self.fbb_.push_slot::<f32>(DomainContext::VT_TRANSFER_SCORE, transfer_score, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DomainContextBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DomainContextBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DomainContext<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DomainContext<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DomainContext");
      ds.field("source_domain", &self.source_domain());
      ds.field("target_domain", &self.target_domain());
      ds.field("embedding", &self.embedding());
      ds.field("confidence", &self.confidence());
      ds.field("transfer_score", &self.transfer_score());
      ds.finish()
  }
}
pub enum WitnessEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Single entry in the append-only RVF Witness Chain.
/// Signed by the authoring system; the pq_signature field carries the
/// post-quantum wrapper from the Decoupled Hardware CA (optional at chain bootstrap).
pub struct WitnessEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WitnessEntry<'a> {
  type Inner = WitnessEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> WitnessEntry<'a> {
  pub const VT_HEIGHT: flatbuffers::VOffsetT = 4;
  pub const VT_PREV_DIGEST: flatbuffers::VOffsetT = 6;
  pub const VT_PAYLOAD_DIGEST: flatbuffers::VOffsetT = 8;
  pub const VT_SIGNATURE: flatbuffers::VOffsetT = 10;
  pub const VT_PUBLIC_KEY: flatbuffers::VOffsetT = 12;
  pub const VT_TIMESTAMP_NS: flatbuffers::VOffsetT = 14;
  pub const VT_AUTHOR: flatbuffers::VOffsetT = 16;
  pub const VT_PQ_SIGNATURE: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    WitnessEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args WitnessEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<WitnessEntry<'bldr>> {
    let mut builder = WitnessEntryBuilder::new(_fbb);
    builder.add_timestamp_ns(args.timestamp_ns);
    builder.add_height(args.height);
    if let Some(x) = args.pq_signature { builder.add_pq_signature(x); }
    if let Some(x) = args.public_key { builder.add_public_key(x); }
    if let Some(x) = args.signature { builder.add_signature(x); }
    if let Some(x) = args.payload_digest { builder.add_payload_digest(x); }
    if let Some(x) = args.prev_digest { builder.add_prev_digest(x); }
    builder.add_author(args.author);
    builder.finish()
  }


  #[inline]
  pub fn height(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(WitnessEntry::VT_HEIGHT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn prev_digest(&self) -> Option<&'a Xxh3Digest> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Xxh3Digest>(WitnessEntry::VT_PREV_DIGEST, None)}
  }
  #[inline]
  pub fn payload_digest(&self) -> Option<&'a Xxh3Digest> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Xxh3Digest>(WitnessEntry::VT_PAYLOAD_DIGEST, None)}
  }
  #[inline]
  pub fn signature(&self) -> Option<&'a Ed25519Signature> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Ed25519Signature>(WitnessEntry::VT_SIGNATURE, None)}
  }
  #[inline]
  pub fn public_key(&self) -> Option<&'a Ed25519PublicKey> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Ed25519PublicKey>(WitnessEntry::VT_PUBLIC_KEY, None)}
  }
  #[inline]
  pub fn timestamp_ns(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(WitnessEntry::VT_TIMESTAMP_NS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn author(&self) -> SystemId {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<SystemId>(WitnessEntry::VT_AUTHOR, Some(SystemId::Unknown)).unwrap()}
  }
  #[inline]
  pub fn pq_signature(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(WitnessEntry::VT_PQ_SIGNATURE, None)}
  }
}

impl flatbuffers::Verifiable for WitnessEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("height", Self::VT_HEIGHT, false)?
     .visit_field::<Xxh3Digest>("prev_digest", Self::VT_PREV_DIGEST, false)?
     .visit_field::<Xxh3Digest>("payload_digest", Self::VT_PAYLOAD_DIGEST, false)?
     .visit_field::<Ed25519Signature>("signature", Self::VT_SIGNATURE, false)?
     .visit_field::<Ed25519PublicKey>("public_key", Self::VT_PUBLIC_KEY, false)?
     .visit_field::<u64>("timestamp_ns", Self::VT_TIMESTAMP_NS, false)?
     .visit_field::<SystemId>("author", Self::VT_AUTHOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("pq_signature", Self::VT_PQ_SIGNATURE, false)?
     .finish();
    Ok(())
  }
}
pub struct WitnessEntryArgs<'a> {
    pub height: u64,
    pub prev_digest: Option<&'a Xxh3Digest>,
    pub payload_digest: Option<&'a Xxh3Digest>,
    pub signature: Option<&'a Ed25519Signature>,
    pub public_key: Option<&'a Ed25519PublicKey>,
    pub timestamp_ns: u64,
    pub author: SystemId,
    pub pq_signature: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for WitnessEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    WitnessEntryArgs {
      height: 0,
      prev_digest: None,
      payload_digest: None,
      signature: None,
      public_key: None,
      timestamp_ns: 0,
      author: SystemId::Unknown,
      pq_signature: None,
    }
  }
}

pub struct WitnessEntryBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WitnessEntryBuilder<'a, 'b> {
  #[inline]
  pub fn add_height(&mut self, height: u64) {
    self.fbb_.push_slot::<u64>(WitnessEntry::VT_HEIGHT, height, 0);
  }
  #[inline]
  pub fn add_prev_digest(&mut self, prev_digest: &Xxh3Digest) {
    self.fbb_.push_slot_always::<&Xxh3Digest>(WitnessEntry::VT_PREV_DIGEST, prev_digest);
  }
  #[inline]
  pub fn add_payload_digest(&mut self, payload_digest: &Xxh3Digest) {
    self.fbb_.push_slot_always::<&Xxh3Digest>(WitnessEntry::VT_PAYLOAD_DIGEST, payload_digest);
  }
  #[inline]
  pub fn add_signature(&mut self, signature: &Ed25519Signature) {
    self.fbb_.push_slot_always::<&Ed25519Signature>(WitnessEntry::VT_SIGNATURE, signature);
  }
  #[inline]
  pub fn add_public_key(&mut self, public_key: &Ed25519PublicKey) {
    self.fbb_.push_slot_always::<&Ed25519PublicKey>(WitnessEntry::VT_PUBLIC_KEY, public_key);
  }
  #[inline]
  pub fn add_timestamp_ns(&mut self, timestamp_ns: u64) {
    self.fbb_.push_slot::<u64>(WitnessEntry::VT_TIMESTAMP_NS, timestamp_ns, 0);
  }
  #[inline]
  pub fn add_author(&mut self, author: SystemId) {
    self.fbb_.push_slot::<SystemId>(WitnessEntry::VT_AUTHOR, author, SystemId::Unknown);
  }
  #[inline]
  pub fn add_pq_signature(&mut self, pq_signature: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WitnessEntry::VT_PQ_SIGNATURE, pq_signature);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> WitnessEntryBuilder<'a, 'b> {
    let start = _fbb.start_table();
    WitnessEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WitnessEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for WitnessEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("WitnessEntry");
      ds.field("height", &self.height());
      ds.field("prev_digest", &self.prev_digest());
      ds.field("payload_digest", &self.payload_digest());
      ds.field("signature", &self.signature());
      ds.field("public_key", &self.public_key());
      ds.field("timestamp_ns", &self.timestamp_ns());
      ds.field("author", &self.author());
      ds.field("pq_signature", &self.pq_signature());
      ds.finish()
  }
}
}  // pub mod common
}  // pub mod mothership

