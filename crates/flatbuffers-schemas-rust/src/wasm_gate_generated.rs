#![allow(warnings)]
// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use crate::common_generated::*;
use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod mothership {
  // Re-export so that `super::common::*` paths from nested modules resolve correctly.
  pub use crate::common_generated::mothership::common;

  use crate::common_generated::*;
  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod wasm_gate {

  use crate::common_generated::*;
  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_POLICY_DECISION: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_POLICY_DECISION: u8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_POLICY_DECISION: [PolicyDecision; 4] = [
  PolicyDecision::Allow,
  PolicyDecision::Deny,
  PolicyDecision::Challenge,
  PolicyDecision::Quarantine,
];

/// Policy decision for an incoming security request.
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct PolicyDecision(pub u8);
#[allow(non_upper_case_globals)]
impl PolicyDecision {
  pub const Allow: Self = Self(0);
  pub const Deny: Self = Self(1);
  pub const Challenge: Self = Self(2);
  pub const Quarantine: Self = Self(3);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Allow,
    Self::Deny,
    Self::Challenge,
    Self::Quarantine,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Allow => Some("Allow"),
      Self::Deny => Some("Deny"),
      Self::Challenge => Some("Challenge"),
      Self::Quarantine => Some("Quarantine"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for PolicyDecision {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for PolicyDecision {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for PolicyDecision {
    type Output = PolicyDecision;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for PolicyDecision {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for PolicyDecision {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for PolicyDecision {}
/// Probabilistic fingerprint bucket array (32 bytes = 4 × uint64).
/// Used for constant-time membership checking without dynamic memory.
// struct ProbabilisticFingerprint, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct ProbabilisticFingerprint(pub [u8; 32]);
impl Default for ProbabilisticFingerprint { 
  fn default() -> Self { 
    Self([0; 32])
  }
}
impl core::fmt::Debug for ProbabilisticFingerprint {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("ProbabilisticFingerprint")
      .field("bucket0", &self.bucket0())
      .field("bucket1", &self.bucket1())
      .field("bucket2", &self.bucket2())
      .field("bucket3", &self.bucket3())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ProbabilisticFingerprint {}
impl<'a> flatbuffers::Follow<'a> for ProbabilisticFingerprint {
  type Inner = &'a ProbabilisticFingerprint;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a ProbabilisticFingerprint>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a ProbabilisticFingerprint {
  type Inner = &'a ProbabilisticFingerprint;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<ProbabilisticFingerprint>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for ProbabilisticFingerprint {
    type Output = ProbabilisticFingerprint;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const ProbabilisticFingerprint as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for ProbabilisticFingerprint {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> ProbabilisticFingerprint {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    bucket0: u64,
    bucket1: u64,
    bucket2: u64,
    bucket3: u64,
  ) -> Self {
    let mut s = Self([0; 32]);
    s.set_bucket0(bucket0);
    s.set_bucket1(bucket1);
    s.set_bucket2(bucket2);
    s.set_bucket3(bucket3);
    s
  }

  pub fn bucket0(&self) -> u64 {
    let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_bucket0(&mut self, x: u64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn bucket1(&self) -> u64 {
    let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[8..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_bucket1(&mut self, x: u64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[8..].as_mut_ptr(),
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn bucket2(&self) -> u64 {
    let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[16..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_bucket2(&mut self, x: u64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[16..].as_mut_ptr(),
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn bucket3(&self) -> u64 {
    let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[24..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_bucket3(&mut self, x: u64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[24..].as_mut_ptr(),
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
    }
  }

}

pub enum SecurityRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Inbound security evaluation request.
/// The caller_did field holds a DID document hash (variable-length; DID formats differ).
/// The domain_context enables the gate to tag the request's semantic domain for
/// downstream threat-intelligence transfer by System 2.
pub struct SecurityRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SecurityRequest<'a> {
  type Inner = SecurityRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SecurityRequest<'a> {
  pub const VT_REQUEST_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CALLER_DID: flatbuffers::VOffsetT = 6;
  pub const VT_PAYLOAD_DIGEST: flatbuffers::VOffsetT = 8;
  pub const VT_PROVENANCE: flatbuffers::VOffsetT = 10;
  pub const VT_DOMAIN_CONTEXT: flatbuffers::VOffsetT = 12;
  pub const VT_FINGERPRINT: flatbuffers::VOffsetT = 14;
  pub const VT_TIMESTAMP_NS: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SecurityRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SecurityRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<SecurityRequest<'bldr>> {
    let mut builder = SecurityRequestBuilder::new(_fbb);
    builder.add_timestamp_ns(args.timestamp_ns);
    builder.add_request_id(args.request_id);
    if let Some(x) = args.fingerprint { builder.add_fingerprint(x); }
    if let Some(x) = args.domain_context { builder.add_domain_context(x); }
    if let Some(x) = args.provenance { builder.add_provenance(x); }
    if let Some(x) = args.payload_digest { builder.add_payload_digest(x); }
    if let Some(x) = args.caller_did { builder.add_caller_did(x); }
    builder.finish()
  }


  #[inline]
  pub fn request_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(SecurityRequest::VT_REQUEST_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn caller_did(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(SecurityRequest::VT_CALLER_DID, None)}
  }
  #[inline]
  pub fn payload_digest(&self) -> Option<&'a super::common::Xxh3Digest> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<super::common::Xxh3Digest>(SecurityRequest::VT_PAYLOAD_DIGEST, None)}
  }
  #[inline]
  pub fn provenance(&self) -> Option<super::common::ProvenanceRecord<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<super::common::ProvenanceRecord>>(SecurityRequest::VT_PROVENANCE, None)}
  }
  #[inline]
  pub fn domain_context(&self) -> Option<super::common::DomainContext<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<super::common::DomainContext>>(SecurityRequest::VT_DOMAIN_CONTEXT, None)}
  }
  #[inline]
  pub fn fingerprint(&self) -> Option<&'a ProbabilisticFingerprint> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ProbabilisticFingerprint>(SecurityRequest::VT_FINGERPRINT, None)}
  }
  #[inline]
  pub fn timestamp_ns(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(SecurityRequest::VT_TIMESTAMP_NS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for SecurityRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("request_id", Self::VT_REQUEST_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("caller_did", Self::VT_CALLER_DID, false)?
     .visit_field::<super::common::Xxh3Digest>("payload_digest", Self::VT_PAYLOAD_DIGEST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<super::common::ProvenanceRecord>>("provenance", Self::VT_PROVENANCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<super::common::DomainContext>>("domain_context", Self::VT_DOMAIN_CONTEXT, false)?
     .visit_field::<ProbabilisticFingerprint>("fingerprint", Self::VT_FINGERPRINT, false)?
     .visit_field::<u64>("timestamp_ns", Self::VT_TIMESTAMP_NS, false)?
     .finish();
    Ok(())
  }
}
pub struct SecurityRequestArgs<'a> {
    pub request_id: u64,
    pub caller_did: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub payload_digest: Option<&'a super::common::Xxh3Digest>,
    pub provenance: Option<flatbuffers::WIPOffset<super::common::ProvenanceRecord<'a>>>,
    pub domain_context: Option<flatbuffers::WIPOffset<super::common::DomainContext<'a>>>,
    pub fingerprint: Option<&'a ProbabilisticFingerprint>,
    pub timestamp_ns: u64,
}
impl<'a> Default for SecurityRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    SecurityRequestArgs {
      request_id: 0,
      caller_did: None,
      payload_digest: None,
      provenance: None,
      domain_context: None,
      fingerprint: None,
      timestamp_ns: 0,
    }
  }
}

pub struct SecurityRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SecurityRequestBuilder<'a, 'b> {
  #[inline]
  pub fn add_request_id(&mut self, request_id: u64) {
    self.fbb_.push_slot::<u64>(SecurityRequest::VT_REQUEST_ID, request_id, 0);
  }
  #[inline]
  pub fn add_caller_did(&mut self, caller_did: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SecurityRequest::VT_CALLER_DID, caller_did);
  }
  #[inline]
  pub fn add_payload_digest(&mut self, payload_digest: &super::common::Xxh3Digest) {
    self.fbb_.push_slot_always::<&super::common::Xxh3Digest>(SecurityRequest::VT_PAYLOAD_DIGEST, payload_digest);
  }
  #[inline]
  pub fn add_provenance(&mut self, provenance: flatbuffers::WIPOffset<super::common::ProvenanceRecord<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::common::ProvenanceRecord>>(SecurityRequest::VT_PROVENANCE, provenance);
  }
  #[inline]
  pub fn add_domain_context(&mut self, domain_context: flatbuffers::WIPOffset<super::common::DomainContext<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::common::DomainContext>>(SecurityRequest::VT_DOMAIN_CONTEXT, domain_context);
  }
  #[inline]
  pub fn add_fingerprint(&mut self, fingerprint: &ProbabilisticFingerprint) {
    self.fbb_.push_slot_always::<&ProbabilisticFingerprint>(SecurityRequest::VT_FINGERPRINT, fingerprint);
  }
  #[inline]
  pub fn add_timestamp_ns(&mut self, timestamp_ns: u64) {
    self.fbb_.push_slot::<u64>(SecurityRequest::VT_TIMESTAMP_NS, timestamp_ns, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SecurityRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SecurityRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SecurityRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SecurityRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SecurityRequest");
      ds.field("request_id", &self.request_id());
      ds.field("caller_did", &self.caller_did());
      ds.field("payload_digest", &self.payload_digest());
      ds.field("provenance", &self.provenance());
      ds.field("domain_context", &self.domain_context());
      ds.field("fingerprint", &self.fingerprint());
      ds.field("timestamp_ns", &self.timestamp_ns());
      ds.finish()
  }
}
pub enum SecurityResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Outbound security evaluation response.
/// reasoning_code is a compact internal status code; no string allocation in WASM.
/// The witness_entry appends this decision to the RVF Witness Chain.
pub struct SecurityResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SecurityResponse<'a> {
  type Inner = SecurityResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SecurityResponse<'a> {
  pub const VT_REQUEST_ID: flatbuffers::VOffsetT = 4;
  pub const VT_DECISION: flatbuffers::VOffsetT = 6;
  pub const VT_THREAT_LEVEL: flatbuffers::VOffsetT = 8;
  pub const VT_PROVENANCE: flatbuffers::VOffsetT = 10;
  pub const VT_DOMAIN_CONTEXT: flatbuffers::VOffsetT = 12;
  pub const VT_REASONING_CODE: flatbuffers::VOffsetT = 14;
  pub const VT_PROCESSING_NS: flatbuffers::VOffsetT = 16;
  pub const VT_WITNESS_ENTRY: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SecurityResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SecurityResponseArgs<'args>
  ) -> flatbuffers::WIPOffset<SecurityResponse<'bldr>> {
    let mut builder = SecurityResponseBuilder::new(_fbb);
    builder.add_processing_ns(args.processing_ns);
    builder.add_request_id(args.request_id);
    if let Some(x) = args.witness_entry { builder.add_witness_entry(x); }
    if let Some(x) = args.domain_context { builder.add_domain_context(x); }
    if let Some(x) = args.provenance { builder.add_provenance(x); }
    builder.add_reasoning_code(args.reasoning_code);
    builder.add_threat_level(args.threat_level);
    builder.add_decision(args.decision);
    builder.finish()
  }


  #[inline]
  pub fn request_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(SecurityResponse::VT_REQUEST_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn decision(&self) -> PolicyDecision {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<PolicyDecision>(SecurityResponse::VT_DECISION, Some(PolicyDecision::Allow)).unwrap()}
  }
  #[inline]
  pub fn threat_level(&self) -> super::common::ThreatLevel {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<super::common::ThreatLevel>(SecurityResponse::VT_THREAT_LEVEL, Some(super::common::ThreatLevel::None)).unwrap()}
  }
  #[inline]
  pub fn provenance(&self) -> Option<super::common::ProvenanceRecord<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<super::common::ProvenanceRecord>>(SecurityResponse::VT_PROVENANCE, None)}
  }
  #[inline]
  pub fn domain_context(&self) -> Option<super::common::DomainContext<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<super::common::DomainContext>>(SecurityResponse::VT_DOMAIN_CONTEXT, None)}
  }
  #[inline]
  pub fn reasoning_code(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(SecurityResponse::VT_REASONING_CODE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn processing_ns(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(SecurityResponse::VT_PROCESSING_NS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn witness_entry(&self) -> Option<super::common::WitnessEntry<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<super::common::WitnessEntry>>(SecurityResponse::VT_WITNESS_ENTRY, None)}
  }
}

impl flatbuffers::Verifiable for SecurityResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("request_id", Self::VT_REQUEST_ID, false)?
     .visit_field::<PolicyDecision>("decision", Self::VT_DECISION, false)?
     .visit_field::<super::common::ThreatLevel>("threat_level", Self::VT_THREAT_LEVEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<super::common::ProvenanceRecord>>("provenance", Self::VT_PROVENANCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<super::common::DomainContext>>("domain_context", Self::VT_DOMAIN_CONTEXT, false)?
     .visit_field::<u16>("reasoning_code", Self::VT_REASONING_CODE, false)?
     .visit_field::<u64>("processing_ns", Self::VT_PROCESSING_NS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<super::common::WitnessEntry>>("witness_entry", Self::VT_WITNESS_ENTRY, false)?
     .finish();
    Ok(())
  }
}
pub struct SecurityResponseArgs<'a> {
    pub request_id: u64,
    pub decision: PolicyDecision,
    pub threat_level: super::common::ThreatLevel,
    pub provenance: Option<flatbuffers::WIPOffset<super::common::ProvenanceRecord<'a>>>,
    pub domain_context: Option<flatbuffers::WIPOffset<super::common::DomainContext<'a>>>,
    pub reasoning_code: u16,
    pub processing_ns: u64,
    pub witness_entry: Option<flatbuffers::WIPOffset<super::common::WitnessEntry<'a>>>,
}
impl<'a> Default for SecurityResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    SecurityResponseArgs {
      request_id: 0,
      decision: PolicyDecision::Allow,
      threat_level: super::common::ThreatLevel::None,
      provenance: None,
      domain_context: None,
      reasoning_code: 0,
      processing_ns: 0,
      witness_entry: None,
    }
  }
}

pub struct SecurityResponseBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SecurityResponseBuilder<'a, 'b> {
  #[inline]
  pub fn add_request_id(&mut self, request_id: u64) {
    self.fbb_.push_slot::<u64>(SecurityResponse::VT_REQUEST_ID, request_id, 0);
  }
  #[inline]
  pub fn add_decision(&mut self, decision: PolicyDecision) {
    self.fbb_.push_slot::<PolicyDecision>(SecurityResponse::VT_DECISION, decision, PolicyDecision::Allow);
  }
  #[inline]
  pub fn add_threat_level(&mut self, threat_level: super::common::ThreatLevel) {
    self.fbb_.push_slot::<super::common::ThreatLevel>(SecurityResponse::VT_THREAT_LEVEL, threat_level, super::common::ThreatLevel::None);
  }
  #[inline]
  pub fn add_provenance(&mut self, provenance: flatbuffers::WIPOffset<super::common::ProvenanceRecord<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::common::ProvenanceRecord>>(SecurityResponse::VT_PROVENANCE, provenance);
  }
  #[inline]
  pub fn add_domain_context(&mut self, domain_context: flatbuffers::WIPOffset<super::common::DomainContext<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::common::DomainContext>>(SecurityResponse::VT_DOMAIN_CONTEXT, domain_context);
  }
  #[inline]
  pub fn add_reasoning_code(&mut self, reasoning_code: u16) {
    self.fbb_.push_slot::<u16>(SecurityResponse::VT_REASONING_CODE, reasoning_code, 0);
  }
  #[inline]
  pub fn add_processing_ns(&mut self, processing_ns: u64) {
    self.fbb_.push_slot::<u64>(SecurityResponse::VT_PROCESSING_NS, processing_ns, 0);
  }
  #[inline]
  pub fn add_witness_entry(&mut self, witness_entry: flatbuffers::WIPOffset<super::common::WitnessEntry<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::common::WitnessEntry>>(SecurityResponse::VT_WITNESS_ENTRY, witness_entry);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SecurityResponseBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SecurityResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SecurityResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SecurityResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SecurityResponse");
      ds.field("request_id", &self.request_id());
      ds.field("decision", &self.decision());
      ds.field("threat_level", &self.threat_level());
      ds.field("provenance", &self.provenance());
      ds.field("domain_context", &self.domain_context());
      ds.field("reasoning_code", &self.reasoning_code());
      ds.field("processing_ns", &self.processing_ns());
      ds.field("witness_entry", &self.witness_entry());
      ds.finish()
  }
}
pub enum SignatureUpdateOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Signature update pushed by System 2 to patch System 1's fingerprint model.
/// This is the only mechanism by which System 1 "learns" — always externally driven.
/// The domain_context indicates which threat domain prompted this update.
pub struct SignatureUpdate<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SignatureUpdate<'a> {
  type Inner = SignatureUpdate<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SignatureUpdate<'a> {
  pub const VT_UPDATE_ID: flatbuffers::VOffsetT = 4;
  pub const VT_NEW_SIGNATURES: flatbuffers::VOffsetT = 6;
  pub const VT_DOMAIN_CONTEXT: flatbuffers::VOffsetT = 8;
  pub const VT_PROVENANCE: flatbuffers::VOffsetT = 10;
  pub const VT_APPLIED_HEIGHT: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SignatureUpdate { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SignatureUpdateArgs<'args>
  ) -> flatbuffers::WIPOffset<SignatureUpdate<'bldr>> {
    let mut builder = SignatureUpdateBuilder::new(_fbb);
    builder.add_applied_height(args.applied_height);
    builder.add_update_id(args.update_id);
    if let Some(x) = args.provenance { builder.add_provenance(x); }
    if let Some(x) = args.domain_context { builder.add_domain_context(x); }
    if let Some(x) = args.new_signatures { builder.add_new_signatures(x); }
    builder.finish()
  }


  #[inline]
  pub fn update_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(SignatureUpdate::VT_UPDATE_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn new_signatures(&self) -> Option<flatbuffers::Vector<'a, ProbabilisticFingerprint>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, ProbabilisticFingerprint>>>(SignatureUpdate::VT_NEW_SIGNATURES, None)}
  }
  #[inline]
  pub fn domain_context(&self) -> Option<super::common::DomainContext<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<super::common::DomainContext>>(SignatureUpdate::VT_DOMAIN_CONTEXT, None)}
  }
  #[inline]
  pub fn provenance(&self) -> Option<super::common::ProvenanceRecord<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<super::common::ProvenanceRecord>>(SignatureUpdate::VT_PROVENANCE, None)}
  }
  #[inline]
  pub fn applied_height(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(SignatureUpdate::VT_APPLIED_HEIGHT, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for SignatureUpdate<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("update_id", Self::VT_UPDATE_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, ProbabilisticFingerprint>>>("new_signatures", Self::VT_NEW_SIGNATURES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<super::common::DomainContext>>("domain_context", Self::VT_DOMAIN_CONTEXT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<super::common::ProvenanceRecord>>("provenance", Self::VT_PROVENANCE, false)?
     .visit_field::<u64>("applied_height", Self::VT_APPLIED_HEIGHT, false)?
     .finish();
    Ok(())
  }
}
pub struct SignatureUpdateArgs<'a> {
    pub update_id: u64,
    pub new_signatures: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, ProbabilisticFingerprint>>>,
    pub domain_context: Option<flatbuffers::WIPOffset<super::common::DomainContext<'a>>>,
    pub provenance: Option<flatbuffers::WIPOffset<super::common::ProvenanceRecord<'a>>>,
    pub applied_height: u64,
}
impl<'a> Default for SignatureUpdateArgs<'a> {
  #[inline]
  fn default() -> Self {
    SignatureUpdateArgs {
      update_id: 0,
      new_signatures: None,
      domain_context: None,
      provenance: None,
      applied_height: 0,
    }
  }
}

pub struct SignatureUpdateBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SignatureUpdateBuilder<'a, 'b> {
  #[inline]
  pub fn add_update_id(&mut self, update_id: u64) {
    self.fbb_.push_slot::<u64>(SignatureUpdate::VT_UPDATE_ID, update_id, 0);
  }
  #[inline]
  pub fn add_new_signatures(&mut self, new_signatures: flatbuffers::WIPOffset<flatbuffers::Vector<'b , ProbabilisticFingerprint>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SignatureUpdate::VT_NEW_SIGNATURES, new_signatures);
  }
  #[inline]
  pub fn add_domain_context(&mut self, domain_context: flatbuffers::WIPOffset<super::common::DomainContext<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::common::DomainContext>>(SignatureUpdate::VT_DOMAIN_CONTEXT, domain_context);
  }
  #[inline]
  pub fn add_provenance(&mut self, provenance: flatbuffers::WIPOffset<super::common::ProvenanceRecord<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::common::ProvenanceRecord>>(SignatureUpdate::VT_PROVENANCE, provenance);
  }
  #[inline]
  pub fn add_applied_height(&mut self, applied_height: u64) {
    self.fbb_.push_slot::<u64>(SignatureUpdate::VT_APPLIED_HEIGHT, applied_height, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SignatureUpdateBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SignatureUpdateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SignatureUpdate<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SignatureUpdate<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SignatureUpdate");
      ds.field("update_id", &self.update_id());
      ds.field("new_signatures", &self.new_signatures());
      ds.field("domain_context", &self.domain_context());
      ds.field("provenance", &self.provenance());
      ds.field("applied_height", &self.applied_height());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `SecurityRequest`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_security_request_unchecked`.
pub fn root_as_security_request(buf: &[u8]) -> Result<SecurityRequest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<SecurityRequest>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `SecurityRequest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_security_request_unchecked`.
pub fn size_prefixed_root_as_security_request(buf: &[u8]) -> Result<SecurityRequest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<SecurityRequest>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `SecurityRequest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_security_request_unchecked`.
pub fn root_as_security_request_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<SecurityRequest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<SecurityRequest<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `SecurityRequest` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_security_request_unchecked`.
pub fn size_prefixed_root_as_security_request_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<SecurityRequest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<SecurityRequest<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a SecurityRequest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `SecurityRequest`.
pub unsafe fn root_as_security_request_unchecked(buf: &[u8]) -> SecurityRequest {
  flatbuffers::root_unchecked::<SecurityRequest>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed SecurityRequest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `SecurityRequest`.
pub unsafe fn size_prefixed_root_as_security_request_unchecked(buf: &[u8]) -> SecurityRequest {
  flatbuffers::size_prefixed_root_unchecked::<SecurityRequest>(buf)
}
#[inline]
pub fn finish_security_request_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<SecurityRequest<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_security_request_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<SecurityRequest<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod wasm_gate
}  // pub mod mothership

