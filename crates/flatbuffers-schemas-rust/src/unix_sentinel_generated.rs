#![allow(warnings)]
// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use crate::common_generated::*;
use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod mothership {
  pub use crate::common_generated::mothership::common;

  use crate::common_generated::*;
  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod sentinel {

  use crate::common_generated::*;
  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_BEHAVIOR_CLASS: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_BEHAVIOR_CLASS: u8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_BEHAVIOR_CLASS: [BehaviorClass; 4] = [
  BehaviorClass::Normal,
  BehaviorClass::Anomalous,
  BehaviorClass::Suspicious,
  BehaviorClass::Malicious,
];

/// Behavioural classification output by the sentinel's anomaly detector.
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct BehaviorClass(pub u8);
#[allow(non_upper_case_globals)]
impl BehaviorClass {
  pub const Normal: Self = Self(0);
  pub const Anomalous: Self = Self(1);
  pub const Suspicious: Self = Self(2);
  pub const Malicious: Self = Self(3);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Normal,
    Self::Anomalous,
    Self::Suspicious,
    Self::Malicious,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Normal => Some("Normal"),
      Self::Anomalous => Some("Anomalous"),
      Self::Suspicious => Some("Suspicious"),
      Self::Malicious => Some("Malicious"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for BehaviorClass {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for BehaviorClass {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for BehaviorClass {
    type Output = BehaviorClass;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for BehaviorClass {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for BehaviorClass {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for BehaviorClass {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_COUNTERMEASURE_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_COUNTERMEASURE_TYPE: u8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_COUNTERMEASURE_TYPE: [CountermeasureType; 6] = [
  CountermeasureType::None,
  CountermeasureType::RateLimitIncrease,
  CountermeasureType::SignaturePatch,
  CountermeasureType::PolicyTighten,
  CountermeasureType::CircuitBreak,
  CountermeasureType::Escalate,
];

/// The type of countermeasure the sentinel orders after a behavioural evaluation.
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct CountermeasureType(pub u8);
#[allow(non_upper_case_globals)]
impl CountermeasureType {
  pub const None: Self = Self(0);
  pub const RateLimitIncrease: Self = Self(1);
  pub const SignaturePatch: Self = Self(2);
  pub const PolicyTighten: Self = Self(3);
  pub const CircuitBreak: Self = Self(4);
  pub const Escalate: Self = Self(5);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::None,
    Self::RateLimitIncrease,
    Self::SignaturePatch,
    Self::PolicyTighten,
    Self::CircuitBreak,
    Self::Escalate,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::None => Some("None"),
      Self::RateLimitIncrease => Some("RateLimitIncrease"),
      Self::SignaturePatch => Some("SignaturePatch"),
      Self::PolicyTighten => Some("PolicyTighten"),
      Self::CircuitBreak => Some("CircuitBreak"),
      Self::Escalate => Some("Escalate"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for CountermeasureType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for CountermeasureType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for CountermeasureType {
    type Output = CountermeasureType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for CountermeasureType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for CountermeasureType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for CountermeasureType {}
pub enum ThreatReportOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Inbound threat report â€” originated by System 1 or an internal sentinel sensor.
/// raw_features carries the ONNX embedding of the triggering payload for LoRA inference.
/// The domain_context field enables cross-domain transfer: a financial-fraud signal can
/// inform a network-security model via the DomainId transfer_score.
pub struct ThreatReport<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ThreatReport<'a> {
  type Inner = ThreatReport<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ThreatReport<'a> {
  pub const VT_REPORT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_SOURCE_SYSTEM: flatbuffers::VOffsetT = 6;
  pub const VT_THREAT_LEVEL: flatbuffers::VOffsetT = 8;
  pub const VT_BEHAVIOR_CLASS: flatbuffers::VOffsetT = 10;
  pub const VT_DOMAIN_CONTEXT: flatbuffers::VOffsetT = 12;
  pub const VT_PROVENANCE: flatbuffers::VOffsetT = 14;
  pub const VT_RAW_FEATURES: flatbuffers::VOffsetT = 16;
  pub const VT_TIMESTAMP_NS: flatbuffers::VOffsetT = 18;
  pub const VT_SEQUENCE_ID: flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ThreatReport { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ThreatReportArgs<'args>
  ) -> flatbuffers::WIPOffset<ThreatReport<'bldr>> {
    let mut builder = ThreatReportBuilder::new(_fbb);
    builder.add_sequence_id(args.sequence_id);
    builder.add_timestamp_ns(args.timestamp_ns);
    builder.add_report_id(args.report_id);
    if let Some(x) = args.raw_features { builder.add_raw_features(x); }
    if let Some(x) = args.provenance { builder.add_provenance(x); }
    if let Some(x) = args.domain_context { builder.add_domain_context(x); }
    builder.add_behavior_class(args.behavior_class);
    builder.add_threat_level(args.threat_level);
    builder.add_source_system(args.source_system);
    builder.finish()
  }


  #[inline]
  pub fn report_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ThreatReport::VT_REPORT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn source_system(&self) -> super::common::SystemId {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<super::common::SystemId>(ThreatReport::VT_SOURCE_SYSTEM, Some(super::common::SystemId::Unknown)).unwrap()}
  }
  #[inline]
  pub fn threat_level(&self) -> super::common::ThreatLevel {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<super::common::ThreatLevel>(ThreatReport::VT_THREAT_LEVEL, Some(super::common::ThreatLevel::None)).unwrap()}
  }
  #[inline]
  pub fn behavior_class(&self) -> BehaviorClass {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<BehaviorClass>(ThreatReport::VT_BEHAVIOR_CLASS, Some(BehaviorClass::Normal)).unwrap()}
  }
  #[inline]
  pub fn domain_context(&self) -> Option<super::common::DomainContext<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<super::common::DomainContext>>(ThreatReport::VT_DOMAIN_CONTEXT, None)}
  }
  #[inline]
  pub fn provenance(&self) -> Option<super::common::ProvenanceRecord<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<super::common::ProvenanceRecord>>(ThreatReport::VT_PROVENANCE, None)}
  }
  #[inline]
  pub fn raw_features(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(ThreatReport::VT_RAW_FEATURES, None)}
  }
  #[inline]
  pub fn timestamp_ns(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ThreatReport::VT_TIMESTAMP_NS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn sequence_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ThreatReport::VT_SEQUENCE_ID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ThreatReport<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("report_id", Self::VT_REPORT_ID, false)?
     .visit_field::<super::common::SystemId>("source_system", Self::VT_SOURCE_SYSTEM, false)?
     .visit_field::<super::common::ThreatLevel>("threat_level", Self::VT_THREAT_LEVEL, false)?
     .visit_field::<BehaviorClass>("behavior_class", Self::VT_BEHAVIOR_CLASS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<super::common::DomainContext>>("domain_context", Self::VT_DOMAIN_CONTEXT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<super::common::ProvenanceRecord>>("provenance", Self::VT_PROVENANCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>("raw_features", Self::VT_RAW_FEATURES, false)?
     .visit_field::<u64>("timestamp_ns", Self::VT_TIMESTAMP_NS, false)?
     .visit_field::<u64>("sequence_id", Self::VT_SEQUENCE_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct ThreatReportArgs<'a> {
    pub report_id: u64,
    pub source_system: super::common::SystemId,
    pub threat_level: super::common::ThreatLevel,
    pub behavior_class: BehaviorClass,
    pub domain_context: Option<flatbuffers::WIPOffset<super::common::DomainContext<'a>>>,
    pub provenance: Option<flatbuffers::WIPOffset<super::common::ProvenanceRecord<'a>>>,
    pub raw_features: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub timestamp_ns: u64,
    pub sequence_id: u64,
}
impl<'a> Default for ThreatReportArgs<'a> {
  #[inline]
  fn default() -> Self {
    ThreatReportArgs {
      report_id: 0,
      source_system: super::common::SystemId::Unknown,
      threat_level: super::common::ThreatLevel::None,
      behavior_class: BehaviorClass::Normal,
      domain_context: None,
      provenance: None,
      raw_features: None,
      timestamp_ns: 0,
      sequence_id: 0,
    }
  }
}

pub struct ThreatReportBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ThreatReportBuilder<'a, 'b> {
  #[inline]
  pub fn add_report_id(&mut self, report_id: u64) {
    self.fbb_.push_slot::<u64>(ThreatReport::VT_REPORT_ID, report_id, 0);
  }
  #[inline]
  pub fn add_source_system(&mut self, source_system: super::common::SystemId) {
    self.fbb_.push_slot::<super::common::SystemId>(ThreatReport::VT_SOURCE_SYSTEM, source_system, super::common::SystemId::Unknown);
  }
  #[inline]
  pub fn add_threat_level(&mut self, threat_level: super::common::ThreatLevel) {
    self.fbb_.push_slot::<super::common::ThreatLevel>(ThreatReport::VT_THREAT_LEVEL, threat_level, super::common::ThreatLevel::None);
  }
  #[inline]
  pub fn add_behavior_class(&mut self, behavior_class: BehaviorClass) {
    self.fbb_.push_slot::<BehaviorClass>(ThreatReport::VT_BEHAVIOR_CLASS, behavior_class, BehaviorClass::Normal);
  }
  #[inline]
  pub fn add_domain_context(&mut self, domain_context: flatbuffers::WIPOffset<super::common::DomainContext<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::common::DomainContext>>(ThreatReport::VT_DOMAIN_CONTEXT, domain_context);
  }
  #[inline]
  pub fn add_provenance(&mut self, provenance: flatbuffers::WIPOffset<super::common::ProvenanceRecord<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::common::ProvenanceRecord>>(ThreatReport::VT_PROVENANCE, provenance);
  }
  #[inline]
  pub fn add_raw_features(&mut self, raw_features: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ThreatReport::VT_RAW_FEATURES, raw_features);
  }
  #[inline]
  pub fn add_timestamp_ns(&mut self, timestamp_ns: u64) {
    self.fbb_.push_slot::<u64>(ThreatReport::VT_TIMESTAMP_NS, timestamp_ns, 0);
  }
  #[inline]
  pub fn add_sequence_id(&mut self, sequence_id: u64) {
    self.fbb_.push_slot::<u64>(ThreatReport::VT_SEQUENCE_ID, sequence_id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ThreatReportBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ThreatReportBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ThreatReport<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ThreatReport<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ThreatReport");
      ds.field("report_id", &self.report_id());
      ds.field("source_system", &self.source_system());
      ds.field("threat_level", &self.threat_level());
      ds.field("behavior_class", &self.behavior_class());
      ds.field("domain_context", &self.domain_context());
      ds.field("provenance", &self.provenance());
      ds.field("raw_features", &self.raw_features());
      ds.field("timestamp_ns", &self.timestamp_ns());
      ds.field("sequence_id", &self.sequence_id());
      ds.finish()
  }
}
pub enum BehaviorEvaluationOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Behavioural evaluation result produced by the sentinel's inference pipeline.
/// lambda_estimate and partition_ratio expose the Stoer-Wagner and partitionRatioScore
/// discriminants for observability (matches existing async-auditor architecture).
pub struct BehaviorEvaluation<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BehaviorEvaluation<'a> {
  type Inner = BehaviorEvaluation<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BehaviorEvaluation<'a> {
  pub const VT_REPORT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_BEHAVIOR_CLASS: flatbuffers::VOffsetT = 6;
  pub const VT_THREAT_LEVEL: flatbuffers::VOffsetT = 8;
  pub const VT_DOMAIN_CONTEXT: flatbuffers::VOffsetT = 10;
  pub const VT_ANOMALY_SCORE: flatbuffers::VOffsetT = 12;
  pub const VT_LAMBDA_ESTIMATE: flatbuffers::VOffsetT = 14;
  pub const VT_PARTITION_RATIO: flatbuffers::VOffsetT = 16;
  pub const VT_STAR_LAMBDA: flatbuffers::VOffsetT = 18;
  pub const VT_PROVENANCE: flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BehaviorEvaluation { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args BehaviorEvaluationArgs<'args>
  ) -> flatbuffers::WIPOffset<BehaviorEvaluation<'bldr>> {
    let mut builder = BehaviorEvaluationBuilder::new(_fbb);
    builder.add_report_id(args.report_id);
    if let Some(x) = args.provenance { builder.add_provenance(x); }
    builder.add_star_lambda(args.star_lambda);
    builder.add_partition_ratio(args.partition_ratio);
    builder.add_lambda_estimate(args.lambda_estimate);
    builder.add_anomaly_score(args.anomaly_score);
    if let Some(x) = args.domain_context { builder.add_domain_context(x); }
    builder.add_threat_level(args.threat_level);
    builder.add_behavior_class(args.behavior_class);
    builder.finish()
  }


  #[inline]
  pub fn report_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(BehaviorEvaluation::VT_REPORT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn behavior_class(&self) -> BehaviorClass {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<BehaviorClass>(BehaviorEvaluation::VT_BEHAVIOR_CLASS, Some(BehaviorClass::Normal)).unwrap()}
  }
  #[inline]
  pub fn threat_level(&self) -> super::common::ThreatLevel {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<super::common::ThreatLevel>(BehaviorEvaluation::VT_THREAT_LEVEL, Some(super::common::ThreatLevel::None)).unwrap()}
  }
  #[inline]
  pub fn domain_context(&self) -> Option<super::common::DomainContext<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<super::common::DomainContext>>(BehaviorEvaluation::VT_DOMAIN_CONTEXT, None)}
  }
  #[inline]
  pub fn anomaly_score(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(BehaviorEvaluation::VT_ANOMALY_SCORE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn lambda_estimate(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(BehaviorEvaluation::VT_LAMBDA_ESTIMATE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn partition_ratio(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(BehaviorEvaluation::VT_PARTITION_RATIO, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn star_lambda(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(BehaviorEvaluation::VT_STAR_LAMBDA, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn provenance(&self) -> Option<super::common::ProvenanceRecord<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<super::common::ProvenanceRecord>>(BehaviorEvaluation::VT_PROVENANCE, None)}
  }
}

impl flatbuffers::Verifiable for BehaviorEvaluation<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("report_id", Self::VT_REPORT_ID, false)?
     .visit_field::<BehaviorClass>("behavior_class", Self::VT_BEHAVIOR_CLASS, false)?
     .visit_field::<super::common::ThreatLevel>("threat_level", Self::VT_THREAT_LEVEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<super::common::DomainContext>>("domain_context", Self::VT_DOMAIN_CONTEXT, false)?
     .visit_field::<f32>("anomaly_score", Self::VT_ANOMALY_SCORE, false)?
     .visit_field::<f32>("lambda_estimate", Self::VT_LAMBDA_ESTIMATE, false)?
     .visit_field::<f32>("partition_ratio", Self::VT_PARTITION_RATIO, false)?
     .visit_field::<f32>("star_lambda", Self::VT_STAR_LAMBDA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<super::common::ProvenanceRecord>>("provenance", Self::VT_PROVENANCE, false)?
     .finish();
    Ok(())
  }
}
pub struct BehaviorEvaluationArgs<'a> {
    pub report_id: u64,
    pub behavior_class: BehaviorClass,
    pub threat_level: super::common::ThreatLevel,
    pub domain_context: Option<flatbuffers::WIPOffset<super::common::DomainContext<'a>>>,
    pub anomaly_score: f32,
    pub lambda_estimate: f32,
    pub partition_ratio: f32,
    pub star_lambda: f32,
    pub provenance: Option<flatbuffers::WIPOffset<super::common::ProvenanceRecord<'a>>>,
}
impl<'a> Default for BehaviorEvaluationArgs<'a> {
  #[inline]
  fn default() -> Self {
    BehaviorEvaluationArgs {
      report_id: 0,
      behavior_class: BehaviorClass::Normal,
      threat_level: super::common::ThreatLevel::None,
      domain_context: None,
      anomaly_score: 0.0,
      lambda_estimate: 0.0,
      partition_ratio: 0.0,
      star_lambda: 0.0,
      provenance: None,
    }
  }
}

pub struct BehaviorEvaluationBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BehaviorEvaluationBuilder<'a, 'b> {
  #[inline]
  pub fn add_report_id(&mut self, report_id: u64) {
    self.fbb_.push_slot::<u64>(BehaviorEvaluation::VT_REPORT_ID, report_id, 0);
  }
  #[inline]
  pub fn add_behavior_class(&mut self, behavior_class: BehaviorClass) {
    self.fbb_.push_slot::<BehaviorClass>(BehaviorEvaluation::VT_BEHAVIOR_CLASS, behavior_class, BehaviorClass::Normal);
  }
  #[inline]
  pub fn add_threat_level(&mut self, threat_level: super::common::ThreatLevel) {
    self.fbb_.push_slot::<super::common::ThreatLevel>(BehaviorEvaluation::VT_THREAT_LEVEL, threat_level, super::common::ThreatLevel::None);
  }
  #[inline]
  pub fn add_domain_context(&mut self, domain_context: flatbuffers::WIPOffset<super::common::DomainContext<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::common::DomainContext>>(BehaviorEvaluation::VT_DOMAIN_CONTEXT, domain_context);
  }
  #[inline]
  pub fn add_anomaly_score(&mut self, anomaly_score: f32) {
    self.fbb_.push_slot::<f32>(BehaviorEvaluation::VT_ANOMALY_SCORE, anomaly_score, 0.0);
  }
  #[inline]
  pub fn add_lambda_estimate(&mut self, lambda_estimate: f32) {
    self.fbb_.push_slot::<f32>(BehaviorEvaluation::VT_LAMBDA_ESTIMATE, lambda_estimate, 0.0);
  }
  #[inline]
  pub fn add_partition_ratio(&mut self, partition_ratio: f32) {
    self.fbb_.push_slot::<f32>(BehaviorEvaluation::VT_PARTITION_RATIO, partition_ratio, 0.0);
  }
  #[inline]
  pub fn add_star_lambda(&mut self, star_lambda: f32) {
    self.fbb_.push_slot::<f32>(BehaviorEvaluation::VT_STAR_LAMBDA, star_lambda, 0.0);
  }
  #[inline]
  pub fn add_provenance(&mut self, provenance: flatbuffers::WIPOffset<super::common::ProvenanceRecord<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::common::ProvenanceRecord>>(BehaviorEvaluation::VT_PROVENANCE, provenance);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BehaviorEvaluationBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BehaviorEvaluationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BehaviorEvaluation<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BehaviorEvaluation<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BehaviorEvaluation");
      ds.field("report_id", &self.report_id());
      ds.field("behavior_class", &self.behavior_class());
      ds.field("threat_level", &self.threat_level());
      ds.field("domain_context", &self.domain_context());
      ds.field("anomaly_score", &self.anomaly_score());
      ds.field("lambda_estimate", &self.lambda_estimate());
      ds.field("partition_ratio", &self.partition_ratio());
      ds.field("star_lambda", &self.star_lambda());
      ds.field("provenance", &self.provenance());
      ds.finish()
  }
}
pub enum CountermeasureDirectiveOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Directive issued by the sentinel to a target system.
/// lora_patch_payload carries a serialised LoRA weight delta when
/// countermeasure = SignaturePatch (zero bytes otherwise).
pub struct CountermeasureDirective<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CountermeasureDirective<'a> {
  type Inner = CountermeasureDirective<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CountermeasureDirective<'a> {
  pub const VT_DIRECTIVE_ID: flatbuffers::VOffsetT = 4;
  pub const VT_TARGET_SYSTEM: flatbuffers::VOffsetT = 6;
  pub const VT_COUNTERMEASURE: flatbuffers::VOffsetT = 8;
  pub const VT_LORA_PATCH_PAYLOAD: flatbuffers::VOffsetT = 10;
  pub const VT_DOMAIN_CONTEXT: flatbuffers::VOffsetT = 12;
  pub const VT_PROVENANCE: flatbuffers::VOffsetT = 14;
  pub const VT_EFFECTIVE_AT_NS: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CountermeasureDirective { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CountermeasureDirectiveArgs<'args>
  ) -> flatbuffers::WIPOffset<CountermeasureDirective<'bldr>> {
    let mut builder = CountermeasureDirectiveBuilder::new(_fbb);
    builder.add_effective_at_ns(args.effective_at_ns);
    builder.add_directive_id(args.directive_id);
    if let Some(x) = args.provenance { builder.add_provenance(x); }
    if let Some(x) = args.domain_context { builder.add_domain_context(x); }
    if let Some(x) = args.lora_patch_payload { builder.add_lora_patch_payload(x); }
    builder.add_countermeasure(args.countermeasure);
    builder.add_target_system(args.target_system);
    builder.finish()
  }


  #[inline]
  pub fn directive_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(CountermeasureDirective::VT_DIRECTIVE_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn target_system(&self) -> super::common::SystemId {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<super::common::SystemId>(CountermeasureDirective::VT_TARGET_SYSTEM, Some(super::common::SystemId::Unknown)).unwrap()}
  }
  #[inline]
  pub fn countermeasure(&self) -> CountermeasureType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<CountermeasureType>(CountermeasureDirective::VT_COUNTERMEASURE, Some(CountermeasureType::None)).unwrap()}
  }
  #[inline]
  pub fn lora_patch_payload(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(CountermeasureDirective::VT_LORA_PATCH_PAYLOAD, None)}
  }
  #[inline]
  pub fn domain_context(&self) -> Option<super::common::DomainContext<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<super::common::DomainContext>>(CountermeasureDirective::VT_DOMAIN_CONTEXT, None)}
  }
  #[inline]
  pub fn provenance(&self) -> Option<super::common::ProvenanceRecord<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<super::common::ProvenanceRecord>>(CountermeasureDirective::VT_PROVENANCE, None)}
  }
  #[inline]
  pub fn effective_at_ns(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(CountermeasureDirective::VT_EFFECTIVE_AT_NS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for CountermeasureDirective<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("directive_id", Self::VT_DIRECTIVE_ID, false)?
     .visit_field::<super::common::SystemId>("target_system", Self::VT_TARGET_SYSTEM, false)?
     .visit_field::<CountermeasureType>("countermeasure", Self::VT_COUNTERMEASURE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("lora_patch_payload", Self::VT_LORA_PATCH_PAYLOAD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<super::common::DomainContext>>("domain_context", Self::VT_DOMAIN_CONTEXT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<super::common::ProvenanceRecord>>("provenance", Self::VT_PROVENANCE, false)?
     .visit_field::<u64>("effective_at_ns", Self::VT_EFFECTIVE_AT_NS, false)?
     .finish();
    Ok(())
  }
}
pub struct CountermeasureDirectiveArgs<'a> {
    pub directive_id: u64,
    pub target_system: super::common::SystemId,
    pub countermeasure: CountermeasureType,
    pub lora_patch_payload: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub domain_context: Option<flatbuffers::WIPOffset<super::common::DomainContext<'a>>>,
    pub provenance: Option<flatbuffers::WIPOffset<super::common::ProvenanceRecord<'a>>>,
    pub effective_at_ns: u64,
}
impl<'a> Default for CountermeasureDirectiveArgs<'a> {
  #[inline]
  fn default() -> Self {
    CountermeasureDirectiveArgs {
      directive_id: 0,
      target_system: super::common::SystemId::Unknown,
      countermeasure: CountermeasureType::None,
      lora_patch_payload: None,
      domain_context: None,
      provenance: None,
      effective_at_ns: 0,
    }
  }
}

pub struct CountermeasureDirectiveBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CountermeasureDirectiveBuilder<'a, 'b> {
  #[inline]
  pub fn add_directive_id(&mut self, directive_id: u64) {
    self.fbb_.push_slot::<u64>(CountermeasureDirective::VT_DIRECTIVE_ID, directive_id, 0);
  }
  #[inline]
  pub fn add_target_system(&mut self, target_system: super::common::SystemId) {
    self.fbb_.push_slot::<super::common::SystemId>(CountermeasureDirective::VT_TARGET_SYSTEM, target_system, super::common::SystemId::Unknown);
  }
  #[inline]
  pub fn add_countermeasure(&mut self, countermeasure: CountermeasureType) {
    self.fbb_.push_slot::<CountermeasureType>(CountermeasureDirective::VT_COUNTERMEASURE, countermeasure, CountermeasureType::None);
  }
  #[inline]
  pub fn add_lora_patch_payload(&mut self, lora_patch_payload: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CountermeasureDirective::VT_LORA_PATCH_PAYLOAD, lora_patch_payload);
  }
  #[inline]
  pub fn add_domain_context(&mut self, domain_context: flatbuffers::WIPOffset<super::common::DomainContext<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::common::DomainContext>>(CountermeasureDirective::VT_DOMAIN_CONTEXT, domain_context);
  }
  #[inline]
  pub fn add_provenance(&mut self, provenance: flatbuffers::WIPOffset<super::common::ProvenanceRecord<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::common::ProvenanceRecord>>(CountermeasureDirective::VT_PROVENANCE, provenance);
  }
  #[inline]
  pub fn add_effective_at_ns(&mut self, effective_at_ns: u64) {
    self.fbb_.push_slot::<u64>(CountermeasureDirective::VT_EFFECTIVE_AT_NS, effective_at_ns, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CountermeasureDirectiveBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CountermeasureDirectiveBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CountermeasureDirective<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CountermeasureDirective<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CountermeasureDirective");
      ds.field("directive_id", &self.directive_id());
      ds.field("target_system", &self.target_system());
      ds.field("countermeasure", &self.countermeasure());
      ds.field("lora_patch_payload", &self.lora_patch_payload());
      ds.field("domain_context", &self.domain_context());
      ds.field("provenance", &self.provenance());
      ds.field("effective_at_ns", &self.effective_at_ns());
      ds.finish()
  }
}
pub enum CorpusEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A single entry for the ruvector coherence/clean-reference corpus.
/// Stored persistently in ruvbot-coherence.db or ruvbot-clean-reference.db.
/// The domain_context enables the planned dynamic clean-traffic capture backlog item.
pub struct CorpusEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CorpusEntry<'a> {
  type Inner = CorpusEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CorpusEntry<'a> {
  pub const VT_ENTRY_ID: flatbuffers::VOffsetT = 4;
  pub const VT_DOMAIN_CONTEXT: flatbuffers::VOffsetT = 6;
  pub const VT_EMBEDDING: flatbuffers::VOffsetT = 8;
  pub const VT_IS_CLEAN: flatbuffers::VOffsetT = 10;
  pub const VT_PROVENANCE: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CorpusEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CorpusEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<CorpusEntry<'bldr>> {
    let mut builder = CorpusEntryBuilder::new(_fbb);
    builder.add_entry_id(args.entry_id);
    if let Some(x) = args.provenance { builder.add_provenance(x); }
    if let Some(x) = args.embedding { builder.add_embedding(x); }
    if let Some(x) = args.domain_context { builder.add_domain_context(x); }
    builder.add_is_clean(args.is_clean);
    builder.finish()
  }


  #[inline]
  pub fn entry_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(CorpusEntry::VT_ENTRY_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn domain_context(&self) -> Option<super::common::DomainContext<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<super::common::DomainContext>>(CorpusEntry::VT_DOMAIN_CONTEXT, None)}
  }
  #[inline]
  pub fn embedding(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(CorpusEntry::VT_EMBEDDING, None)}
  }
  #[inline]
  pub fn is_clean(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(CorpusEntry::VT_IS_CLEAN, Some(false)).unwrap()}
  }
  #[inline]
  pub fn provenance(&self) -> Option<super::common::ProvenanceRecord<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<super::common::ProvenanceRecord>>(CorpusEntry::VT_PROVENANCE, None)}
  }
}

impl flatbuffers::Verifiable for CorpusEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("entry_id", Self::VT_ENTRY_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<super::common::DomainContext>>("domain_context", Self::VT_DOMAIN_CONTEXT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>("embedding", Self::VT_EMBEDDING, false)?
     .visit_field::<bool>("is_clean", Self::VT_IS_CLEAN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<super::common::ProvenanceRecord>>("provenance", Self::VT_PROVENANCE, false)?
     .finish();
    Ok(())
  }
}
pub struct CorpusEntryArgs<'a> {
    pub entry_id: u64,
    pub domain_context: Option<flatbuffers::WIPOffset<super::common::DomainContext<'a>>>,
    pub embedding: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub is_clean: bool,
    pub provenance: Option<flatbuffers::WIPOffset<super::common::ProvenanceRecord<'a>>>,
}
impl<'a> Default for CorpusEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    CorpusEntryArgs {
      entry_id: 0,
      domain_context: None,
      embedding: None,
      is_clean: false,
      provenance: None,
    }
  }
}

pub struct CorpusEntryBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CorpusEntryBuilder<'a, 'b> {
  #[inline]
  pub fn add_entry_id(&mut self, entry_id: u64) {
    self.fbb_.push_slot::<u64>(CorpusEntry::VT_ENTRY_ID, entry_id, 0);
  }
  #[inline]
  pub fn add_domain_context(&mut self, domain_context: flatbuffers::WIPOffset<super::common::DomainContext<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::common::DomainContext>>(CorpusEntry::VT_DOMAIN_CONTEXT, domain_context);
  }
  #[inline]
  pub fn add_embedding(&mut self, embedding: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CorpusEntry::VT_EMBEDDING, embedding);
  }
  #[inline]
  pub fn add_is_clean(&mut self, is_clean: bool) {
    self.fbb_.push_slot::<bool>(CorpusEntry::VT_IS_CLEAN, is_clean, false);
  }
  #[inline]
  pub fn add_provenance(&mut self, provenance: flatbuffers::WIPOffset<super::common::ProvenanceRecord<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::common::ProvenanceRecord>>(CorpusEntry::VT_PROVENANCE, provenance);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CorpusEntryBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CorpusEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CorpusEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CorpusEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CorpusEntry");
      ds.field("entry_id", &self.entry_id());
      ds.field("domain_context", &self.domain_context());
      ds.field("embedding", &self.embedding());
      ds.field("is_clean", &self.is_clean());
      ds.field("provenance", &self.provenance());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `ThreatReport`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_threat_report_unchecked`.
pub fn root_as_threat_report(buf: &[u8]) -> Result<ThreatReport, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<ThreatReport>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `ThreatReport` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_threat_report_unchecked`.
pub fn size_prefixed_root_as_threat_report(buf: &[u8]) -> Result<ThreatReport, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<ThreatReport>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `ThreatReport` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_threat_report_unchecked`.
pub fn root_as_threat_report_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ThreatReport<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<ThreatReport<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `ThreatReport` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_threat_report_unchecked`.
pub fn size_prefixed_root_as_threat_report_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ThreatReport<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<ThreatReport<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a ThreatReport and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `ThreatReport`.
pub unsafe fn root_as_threat_report_unchecked(buf: &[u8]) -> ThreatReport {
  flatbuffers::root_unchecked::<ThreatReport>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed ThreatReport and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `ThreatReport`.
pub unsafe fn size_prefixed_root_as_threat_report_unchecked(buf: &[u8]) -> ThreatReport {
  flatbuffers::size_prefixed_root_unchecked::<ThreatReport>(buf)
}
#[inline]
pub fn finish_threat_report_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<ThreatReport<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_threat_report_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<ThreatReport<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod sentinel
}  // pub mod mothership

