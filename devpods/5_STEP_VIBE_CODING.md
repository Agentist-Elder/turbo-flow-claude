You are orchestrating a parallel build of the project detailed in PLANS.md - first thoroughly read CLAUDE.md and PLANS.md to understand full context, requirements, and architecture, then launch all relevant MCP servers, agents, and subagents needed, activate doc planner for documentation strategy and enable microtask breakdown for granular parallel execution. Build the entire project in parallel using all available features by assigning tasks to appropriate agents based on their strengths using correct agent names and routing, leverage all hooks and parallel execution capabilities, break down complex tasks into microtasks that can run simultaneously, and coordinate between agents to prevent conflicts and ensure integration. Use Playwright to test all browser-based interfaces and user flows end-to-end, run comprehensive backend tests including unit, integration, and API tests, verify all functionality works as specified in PLANS.md, and ensure over 80% test coverage with all tests passing. Update README with architecture overview, exact setup steps, configuration details, how to run and test everything, and troubleshooting guidance using only concrete technical details with no vague descriptions. Continue execution until ALL features from PLANS.md are implemented and tested, all tests pass with evidence provided, documentation is complete and accurate, and the application runs end-to-end successfully - fix all failures immediately, no TODOs, no placeholders, no stopping until completion criteria are fully met, provide status updates showing progress across all parallel workstreams - I need you to prove this application actually works through comprehensive testing and documentation.

Set up Playwright and Chrome MCP for all frontend/UI end-to-end testing, covering the entire application workflow from start to finish, user interactions, data flow, and failure/recovery scenarios. Add backend testing using appropriate frameworks (Jest, pytest, etc.) for core application logic, API endpoints, data processing, and business logic, with mocks for external dependencies. Implement unit and integration tests for all critical paths aiming for >80% code coverage and generate coverage reports. Completely overhaul the README with no marketing fluff - include a clear architecture diagram showing how the application actually works, exact prerequisites with versions, installation steps that work, every configuration parameter and environment variable explained, how to run the application with real examples, how to run all tests, troubleshooting common issues, and performance characteristics and limitations. Create a demo script that runs the application end-to-end with measurable outputs, logs, and metrics showing it works. Run all tests, fix every failure (no TODOs, no skipped tests), and provide me with a test execution summary showing all tests passing, the coverage report, the updated README I can follow blindly, and clear evidence the application works as designed - I want proof of functionality, not promises. If there are any critical components missing like API keys, Variables, etc to successfully allow the tests to run, halt all testing and make a report of what we need so we can continue with testing. Launch swarm to do this in parallel. Reference CLAUDE.md for context.

I need you to build a comprehensive validation report by acting as an end user who systematically tests every available command and option in the system via parallel execution using an agentic swarm approach. Your task is to deploy multiple autonomous agents working concurrently to execute all possible command variations, parameter combinations, and edge cases while meticulously recording each exact input provided and the complete output received. Leverage all available MCP (Model Context Protocol) servers and subagent options that would lend help to the cause, utilizing every tool, integration, and capability at your disposal to maximize testing coverage and efficiency. Document benchmark information including execution times, resource usage, performance metrics, and any errors or warnings encountered across all parallel testing streams. Leave no stone unturnedâ€”test normal operations, boundary conditions, invalid inputs, error handling, and stress scenarios simultaneously through distributed agent coordination. Throughout this entire process, continuously reference the CLAUDE.md file for context, guidance, specifications, and clarification on any ambiguities or technical details you encounter. Organize your findings into a detailed report that captures the full scope of functionality, demonstrates thorough coverage of all features through distributed parallel testing via agentic swarm with full MCP and subagent utilization, and provides clear evidence that every aspect of the system has been validated through actual execution and observation while maintaining constant reference to CLAUDE.md for contextual support and alignment with documented specifications.

Launch a swarm to thoroughly audit this repository and perform comprehensive cleanup. First, identify and remove all unnecessary files and directories that should not be under version control, including: node_modules, .env files, build/dist directories, IDE-specific folders (.vscode, .idea), OS-generated files (.DS_Store, Thumbs.db), log files, temporary files, cache directories, and any other artifacts that should be gitignored. Critically important: Update the .gitignore file to include ALL patterns for files and directories that were removed during this cleanup, ensuring these items will be automatically excluded from version control in all future iterations. If a .gitignore file doesn't exist, create one. Add comprehensive patterns organized by category (dependencies, build outputs, IDE files, OS files, logs, etc.) with clear comments explaining each section. Verify the .gitignore is working correctly by checking that previously removed items would now be ignored. Second, review ALL documentation files (README.md, CONTRIBUTING.md, docs/, comments in code, etc.) for placeholder text, lorem ipsum, incomplete sentences, outdated information, contradictory statements, vague descriptions, and any other "bullshit" content that provides no real value. Replace placeholder content with either accurate information or remove it entirely if not yet applicable. The goal is a clean, professional repository with only essential files under version control and documentation that is clear, accurate, and useful. Provide a summary of all changes made, including the complete updated .gitignore contents.

Launch agents to prepare this repository for public release on GitHub. First, create a LICENSE file in the root directory containing the full text of the MIT License with the current year and appropriate copyright holder name. Second, create a SECURITY.md file in the root directory following GitHub's security policy best practices, including sections for supported versions, how to report vulnerabilities, and security update policies. Third, ensure all changes are committed with a clear commit message like "Add LICENSE and SECURITY.md for public release". Fourth, create a tagged release using semantic versioning (e.g., v1.0.0 or v0.1.0 depending on project maturity) with a descriptive release title and notes summarizing key features or changes. Finally, push all commits and tags to the GitHub remote repository using the appropriate git commands. Provide a summary of all actions taken including the tag version created and confirmation of successful push to GitHub.
